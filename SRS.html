<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
   /* Base Styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: Arial, sans-serif;
    line-height: 1.6;
    background-color: #f5f5f5;
    min-height: 100vh;
}

/* Top Bar */
.top-bar {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: 50px;
    background: #2c3e50;
    color: white;
    display: flex;
    align-items: center;
    padding: 0 20px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    z-index: 2000;
}

/* Container */
.container {
    max-width: 1000px;
    margin: 20px auto 0;
    padding: 20px;
}

/* Home Page */
.home-container {
    text-align: center;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: calc(100vh - 60px);
    margin-top: 50px;
}

.button-grid {
    display: grid;
    gap: 20px;
    grid-template-columns: repeat(2, 1fr);
    margin: 0 auto;
    max-width: 600px;
    width: 90%;
}

.home-button {
    padding: 30px 20px;
    font-size: 1.2em;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    background: #2c3e50;
    color: white;
    transition: transform 0.2s, background 0.2s;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

.home-button:hover {
    transform: translateY(-2px);
    background: #34495e;
}

/* Overlay Pages */
.overlay-page {
    display: none;
    position: fixed;
    top: 50px;
    left: 0;
    width: 100%;
    height: calc(100% - 50px);
    background: white;
    z-index: 1999;
    overflow-y: auto;
}

.overlay-page.active {
    display: block;
}

/* Close button for overlays */
.close-button {
    position: absolute;
    top: 10px;
    right: 20px;
    background: rgba(44, 62, 80, 0.1);
    border: 2px solid #2c3e50;
    font-size: 28px;
    cursor: pointer;
    color: #2c3e50;
    z-index: 2001;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s;
    padding-bottom: 5px;
}

.close-button:hover {
    background-color: rgba(44, 62, 80, 0.2);
    transform: scale(1.1);
}

/* Deck Grid */
.deck-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 20px;
    margin-top: 20px;
}

.deck-card {
    background: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    cursor: pointer;
    transition: transform 0.2s;
}

.deck-card:hover {
    transform: translateY(-2px);
}

.deck-title {
    font-size: 1.2em;
    margin-bottom: 10px;
    color: #2c3e50;
}

.deck-stats {
    color: #666;
    font-size: 0.9em;
}

/* Create Deck Form */
.create-form {
    background: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    margin-top: 20px;
}

.form-group {
    margin-bottom: 20px;
}

.form-group label {
    display: block;
    margin-bottom: 5px;
    color: #2c3e50;
}

.form-input {
    width: 100%;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 16px;
}

/* Card Creation Area */
.card-creation {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin-top: 20px;
}

.card-side {
    padding: 20px;
    background: #f8f9fa;
    border-radius: 4px;
}

/* Study Interface */
.study-container {
    max-width: 800px;
    margin: 20px auto;
    padding: 20px;
}

/* Updated card display style */
.card-display {
    background: white;
    padding: 40px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    min-height: 300px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    margin-bottom: 20px;
    font-size: 1.5em;
    gap: 20px;
}

.card-front, .card-back {
    width: 100%;
    text-align: center;
    padding: 10px;
}

.card-back {
    border-top: 1px solid #eee;
    margin-top: 10px;
    padding-top: 20px;
}

/* Updated rating buttons style */
.rating-buttons {
    display: flex;
    gap: 5px;
    justify-content: center;
    padding: 10px;
}

.rating-button {
    padding: 10px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background 0.2s;
    min-width: 70px;
    color: white;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 3px;
    font-size: 0.9em;
}

.rating-again { background: #e74c3c; }
.rating-hard { background: #f39c12; }
.rating-good { background: #2ecc71; }
.rating-easy { background: #3498db; }

.rating-button:hover {
    filter: brightness(1.1);
    transform: translateY(-1px);
}

.button {
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    background: #2c3e50;
    color: white;
    cursor: pointer;
    transition: background 0.2s;
}

.button:hover {
    background: #34495e;
}

/* Import Interface */
.import-container {
    margin-top: 20px;
    background: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.file-input {
    margin: 20px 0;
}

.import-preview {
    margin-top: 20px;
    max-height: 300px;
    overflow-y: auto;
}

.preview-table {
    width: 100%;
    border-collapse: collapse;
}

.preview-table th,
.preview-table td {
    padding: 8px;
    border: 1px solid #ddd;
    text-align: left;
}

.preview-table th {
    background: #f5f5f5;
}</style>
</head>
<body>
    <!-- Top Bar -->
    <div class="top-bar">
    </div>

    <!-- Home Page -->
    <div id="homePage" class="page active">
        <div class="home-container">
            <div class="button-grid">
                <button class="home-button" onclick="showOverlay('createDeck')">Create Deck</button>
                <button class="home-button" onclick="showOverlay('import')">Import Cards</button>
                <button class="home-button" onclick="showOverlay('decks')">My Decks</button>
                <button class="home-button" onclick="exportAllDecks()">Export All</button>
            </div>
        </div>
    </div>

    <!-- Create Deck Overlay -->
    <div id="createDeckOverlay" class="overlay-page">
        <button class="close-button" onclick="hideOverlay('createDeck')">&times;</button>
        <div class="container">
            <div class="create-form">
                <div class="form-group">
                    <label for="deckName">Deck Name</label>
                    <input type="text" id="deckName" class="form-input" placeholder="Enter deck name">
                </div>
                <div class="card-creation">
                    <div class="card-side">
                        <label>Front</label>
                        <textarea id="cardFront" class="form-input" rows="4"></textarea>
                    </div>
                    <div class="card-side">
                        <label>Back</label>
                        <textarea id="cardBack" class="form-input" rows="4"></textarea>
                    </div>
                </div>
                <button class="button" onclick="addCard()">Add Card</button>
                <button class="button" onclick="saveDeck()">Save Deck</button>
            </div>
            <div id="cardPreview" class="deck-grid">
                <!-- Added cards will appear here -->
            </div>
        </div>
    </div>

    <!-- Import Overlay -->
    <div id="importOverlay" class="overlay-page">
        <button class="close-button" onclick="hideOverlay('import')">&times;</button>
        <div class="container">
            <div class="import-container">
                <h2>Import Cards</h2>
                <div>
                    <input type="file" id="importFile" accept=".txt,.xlsx" class="file-input" 
                           onchange="handleFileSelect(event)">
                </div>
                <div class="form-group">
                    <label for="importDeckName">Deck Name</label>
                    <input type="text" id="importDeckName" class="form-input" placeholder="Enter deck name">
                </div>
                <div class="import-preview" id="importPreview">
                    <!-- Preview will be shown here -->
                </div>
                <button class="button" onclick="processImport()">Import Cards</button>
            </div>
        </div>
    </div>

    <!-- Decks Overlay -->
    <div id="decksOverlay" class="overlay-page">
        <button class="close-button" onclick="hideOverlay('decks')">&times;</button>
        <div class="container">
            <div id="deckList" class="deck-grid">
                <!-- Decks will be listed here -->
            </div>
        </div>
    </div>

    <!-- Study Overlay -->
    <div id="studyOverlay" class="overlay-page">
        <button class="close-button" onclick="hideOverlay('study')">&times;</button>
        <div class="study-container">
            <div class="card-display">
                <div id="cardContent">
                    <!-- Card content will be inserted here -->
                </div>
            </div>
            <button id="showAnswerBtn" class="button" onclick="showAnswer()">Show Answer</button>
            <div id="ratingButtons" class="rating-buttons" style="display: none;">
                <button class="rating-button rating-again" onclick="rateCard('again')">Again</button>
                <button class="rating-button rating-hard" onclick="rateCard('hard')">Hard</button>
                <button class="rating-button rating-good" onclick="rateCard('good')">Good</button>
                <button class="rating-button rating-easy" onclick="rateCard('easy')">Easy</button>
            </div>
        </div>
    </div>

    <script>
 // Constants for SRS algorithm
const LEARNING_STEPS = [1, 10]; // minutes
const GRADUATING_INTERVAL = 1; // days
const MINIMUM_INTERVAL = 1;
const EASY_BONUS = 1.3;
const INTERVAL_MODIFIER = 1.0;
const MAX_NEW_CARDS_PER_DAY = 10;  // Maximum new cards per day
const MAX_TOTAL_CARDS_PER_DAY = 100;  // Maximum total reviews per day

// Data structures and state
let decks = {};
let currentDeck = null;
let currentCard = null;
let tempCards = []; // For storing cards during deck creation
let studyState = {
    showingAnswer: false,
    cardsToReview: []
};

// Time formatting function
function formatTimeInterval(minutes) {
    if (minutes < 1) return `${Math.round(minutes * 60)}s`;
    if (minutes < 60) return `${Math.round(minutes)}m`;
    if (minutes < 1440) return `${Math.round(minutes / 60)}h`;
    if (minutes < 525600) return `${Math.round(minutes / 1440)}d`;
    return `${Math.round(minutes / 525600)}y`;
}

// Card class
class Card {
    constructor(front, back) {
        this.id = Date.now().toString() + Math.random().toString(36).substr(2, 9);
        this.front = front;
        this.back = back;
        this.interval = 0;
        this.ease = 2.5;
        this.reviews = 0;
        this.lapses = 0;
        this.step = 0;
        this.state = 'new'; // 'new', 'learning', 'review', 'relearning'
        this.dueDate = new Date();
        this.sessionReviewed = false; // Track if card was reviewed in current session
        this.extraDue = false; // Flag for cards that became due while offline
        this.lastReviewDate = new Date().toISOString();
    }

    calculateNextInterval(rating) {
        const now = new Date();
        let nextDate = new Date();
        let interval;

        switch(this.state) {
            case 'new':
            case 'learning':
                if (rating === 'again') {
                    this.step = 0;
                    interval = LEARNING_STEPS[0];
                    nextDate.setMinutes(now.getMinutes() + interval);
                } else if (rating === 'hard') {
                    interval = LEARNING_STEPS[this.step];
                    nextDate.setMinutes(now.getMinutes() + interval);
                } else if (rating === 'good') {
                    if (this.step < LEARNING_STEPS.length - 1) {
                        this.step++;
                        interval = LEARNING_STEPS[this.step];
                        nextDate.setMinutes(now.getMinutes() + interval);
                    } else {
                        this.state = 'review';
                        interval = GRADUATING_INTERVAL * 1440; // convert to minutes
                        nextDate.setMinutes(now.getMinutes() + interval);
                    }
                } else if (rating === 'easy') {
                    this.state = 'review';
                    interval = GRADUATING_INTERVAL * EASY_BONUS * 1440;
                    nextDate.setMinutes(now.getMinutes() + interval);
                }
                break;

            case 'review':
                if (rating === 'again') {
                    this.state = 'relearning';
                    this.step = 0;
                    this.lapses++;
                    interval = LEARNING_STEPS[0];
                    this.ease = Math.max(1.3, this.ease - 0.2);
                    nextDate.setMinutes(now.getMinutes() + interval);
                } else {
                    let factor;
                    if (rating === 'hard') {
                        factor = 1.2;
                        this.ease = Math.max(1.3, this.ease - 0.15);
                    } else if (rating === 'good') {
                        factor = this.ease;
                    } else { // easy
                        factor = this.ease * EASY_BONUS;
                        this.ease += 0.15;
                    }
                    interval = this.interval === 0 ? 
                        GRADUATING_INTERVAL * 1440 : 
                        Math.max(MINIMUM_INTERVAL, this.interval * factor) * 1440;
                    nextDate.setMinutes(now.getMinutes() + interval);
                }
                break;

            case 'relearning':
                if (rating === 'again') {
                    interval = LEARNING_STEPS[0];
                    nextDate.setMinutes(now.getMinutes() + interval);
                } else if (rating === 'good') {
                    this.state = 'review';
                    interval = Math.max(MINIMUM_INTERVAL, Math.round(this.interval / 2)) * 1440;
                    nextDate.setMinutes(now.getMinutes() + interval);
                } else if (rating === 'easy') {
                    this.state = 'review';
                    interval = this.interval * 1440;
                    nextDate.setMinutes(now.getMinutes() + interval);
                }
                break;
        }

        this.interval = interval / 1440; // Convert back to days for storage
        this.dueDate = nextDate;
        this.reviews++;
        this.extraDue = false; // Clear the extra due flag after review
        this.lastReviewDate = now.toISOString();
        return interval;
    }

    getIntervalPreview(rating) {
        let interval;

        switch(this.state) {
            case 'new':
            case 'learning':
                if (rating === 'again') {
                    interval = LEARNING_STEPS[0];
                } else if (rating === 'hard') {
                    interval = LEARNING_STEPS[this.step];
                } else if (rating === 'good') {
                    interval = this.step < LEARNING_STEPS.length - 1 ? 
                        LEARNING_STEPS[this.step + 1] : 
                        GRADUATING_INTERVAL * 1440;
                } else if (rating === 'easy') {
                    interval = GRADUATING_INTERVAL * EASY_BONUS * 1440;
                }
                break;

            case 'review':
                if (rating === 'again') {
                    interval = LEARNING_STEPS[0];
                } else {
                    let factor = rating === 'hard' ? 1.2 :
                                rating === 'good' ? this.ease :
                                this.ease * EASY_BONUS;
                    interval = this.interval === 0 ? 
                        GRADUATING_INTERVAL * 1440 : 
                        this.interval * factor * 1440;
                }
                break;

            case 'relearning':
                if (rating === 'again') {
                    interval = LEARNING_STEPS[0];
                } else if (rating === 'good') {
                    interval = Math.max(MINIMUM_INTERVAL, Math.round(this.interval / 2)) * 1440;
                } else if (rating === 'easy') {
                    interval = this.interval * 1440;
                }
                break;
        }

        return formatTimeInterval(interval);
    }
}

// Deck class
class Deck {
    constructor(name) {
        this.id = Date.now().toString() + Math.random().toString(36).substr(2, 9);
        this.name = name;
        this.cards = {};
        this.created = new Date();
        this.lastReview = null;
        this.newCardsToday = 0;
        this.totalReviewsToday = 0;
        this.lastSyncDate = new Date().toISOString();
        this.lastMaintenanceDate = new Date().toISOString();
    }

    addCard(card) {
        this.cards[card.id] = card;
    }

    performMaintenance() {
        const now = new Date();
        const lastSync = new Date(this.lastSyncDate);
        const lastMaintenance = new Date(this.lastMaintenanceDate);
        
        // Check if a new day has started (using UTC to avoid timezone issues)
        if (lastMaintenance.getUTCDate() !== now.getUTCDate() || 
            lastMaintenance.getUTCMonth() !== now.getUTCMonth() || 
            lastMaintenance.getUTCFullYear() !== now.getUTCFullYear()) {
            
            // Reset daily counters
            this.newCardsToday = 0;
            this.totalReviewsToday = 0;
            
            // Calculate days passed since last sync
            const daysPassed = Math.floor((now - lastSync) / (1000 * 60 * 60 * 24));
            
            // Update card statistics if multiple days have passed
            if (daysPassed > 1) {
                Object.values(this.cards).forEach(card => {
                    // If card was due during the offline period, mark it as extra due
                    if (card.dueDate > lastSync && card.dueDate < now) {
                        card.extraDue = true;
                    }
                });
            }
            
            this.lastMaintenanceDate = now.toISOString();
        }
        
        this.lastSyncDate = now.toISOString();
        saveDecks(); // Save changes to localStorage
    }

    getDueCards() {
        this.performMaintenance();
        const now = new Date();
        
        // Get all due cards
        let dueCards = Object.values(this.cards).filter(card => 
            card.dueDate <= now || card.reviews === 0
        );

        // Sort cards: extra due cards first, then by due date
        dueCards.sort((a, b) => {
            if (a.extraDue && !b.extraDue) return -1;
            if (!a.extraDue && b.extraDue) return 1;
            return a.dueDate - b.dueDate;
        });

        // Separate new cards and review cards
        let newCards = dueCards.filter(card => card.reviews === 0);
        let reviewCards = dueCards.filter(card => card.reviews > 0);

        // Limit new cards
        const remainingNewCards = MAX_NEW_CARDS_PER_DAY - this.newCardsToday;
        if (remainingNewCards > 0) {
            newCards = newCards.slice(0, remainingNewCards);
        } else {
            newCards = [];
        }

        // Combine and limit total cards
        dueCards = [...reviewCards, ...newCards];
        const remainingTotal = MAX_TOTAL_CARDS_PER_DAY - this.totalReviewsToday;
        return remainingTotal > 0 ? dueCards.slice(0, remainingTotal) : [];
    }
}

// Initialize app
document.addEventListener('DOMContentLoaded', function() {
    loadDecks();
    updateDecksList();
});

// Storage functions
function loadDecks() {
    const savedDecks = localStorage.getItem('srs_decks');
    if (savedDecks) {
        const parsed = JSON.parse(savedDecks);
        decks = Object.fromEntries(
            Object.entries(parsed).map(([id, deck]) => {
                const newDeck = new Deck(deck.name);
                Object.assign(newDeck, {
                    id: deck.id,
                    created: new Date(deck.created),
                    lastReview: deck.lastReview ? new Date(deck.lastReview) : null,
                    newCardsToday: deck.newCardsToday || 0,
                    totalReviewsToday: deck.totalReviewsToday || 0,
                    lastSyncDate: deck.lastSyncDate || new Date().toISOString(),
                    lastMaintenanceDate: deck.lastMaintenanceDate || new Date().toISOString()
                });
                
                Object.values(deck.cards).forEach(cardData => {
                    const card = new Card(cardData.front, cardData.back);
                    Object.assign(card, {
                        ...cardData,
                        dueDate: new Date(cardData.dueDate),
                        lastReviewDate: cardData.lastReviewDate || new Date().toISOString()
                    });
                    newDeck.addCard(card);
                });
                
                return [id, newDeck];
            })
        );
    }
}

function saveDecks() {
    localStorage.setItem('srs_decks', JSON.stringify(decks));
}

// UI functions
function showOverlay(overlayId) {
    document.querySelectorAll('.overlay-page').forEach(overlay => {
        overlay.classList.remove('active');
    });
    document.getElementById(overlayId + 'Overlay').classList.add('active');

    if (overlayId === 'decks') {
        updateDecksList();
    }
}

function hideOverlay(overlayId) {
    document.getElementById(overlayId + 'Overlay').classList.remove('active');
    if (overlayId === 'study') {
        // Reset study state when closing study overlay
        studyState.showingAnswer = false;
        studyState.cardsToReview = [];
        currentCard = null;
    }
}

// Deck creation functions
function addCard() {
    const front = document.getElementById('cardFront').value.trim();
    const back = document.getElementById('cardBack').value.trim();

    if (!front || !back) {
        alert('Both front and back are required');
        return;
    }

    const card = new Card(front, back);
    tempCards.push(card);
    
    document.getElementById('cardFront').value = '';
    document.getElementById('cardBack').value = '';

    updateCardPreview();
}

function updateCardPreview() {
    const preview = document.getElementById('cardPreview');
    preview.innerHTML = tempCards.map((card, index) => `
        <div class="deck-card">
            <div class="deck-title">Card ${index + 1}</div>
            <div class="deck-stats">
                <div>Front: ${card.front}</div>
                <div>Back: ${card.back}</div>
            </div>
            <button class="button" onclick="removeCard(${index})">Remove</button>
        </div>
    `).join('');
}

function removeCard(index) {
    tempCards.splice(index, 1);
    updateCardPreview();
}

function saveDeck() {
    const name = document.getElementById('deckName').value.trim();
    
    if (!name) {
        alert('Please enter a deck name');
        return;
    }

    if (tempCards.length === 0) {
        alert('Please add at least one card');
        return;
    }

    const deck = new Deck(name);
    tempCards.forEach(card => deck.addCard(card));
    
    decks[deck.id] = deck;
    saveDecks();

    tempCards = [];
    document.getElementById('deckName').value = '';
    document.getElementById('cardPreview').innerHTML = '';
    hideOverlay('createDeck');
}

// Import functions
function handleFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(e) {
        showImportPreview(e.target.result);
    };
    reader.readAsText(file);
}

function showImportPreview(content) {
    const lines = content.split('\n')
        .map(line => line.trim())
        .filter(line => line);

    const preview = document.getElementById('importPreview');
    preview.innerHTML = `
        <table class="preview-table">
            <thead>
                <tr><th>Front</th><th>Back</th></tr>
            </thead>
            <tbody>
                ${lines.map(line => {
                    const [front, back] = line.split('\t');
                    return `<tr><td>${front}</td><td>${back}</td></tr>`;
                }).join('')}
            </tbody>
        </table>
    `;
}

function processImport() {
    const deckName = document.getElementById('importDeckName').value.trim();
    const fileInput = document.getElementById('importFile');
    const file = fileInput.files[0];

    if (!deckName || !file) {
        alert('Please provide both deck name and file');
        return;
    }

    const reader = new FileReader();
    reader.onload = function(e) {
        const content = e.target.result;
        const deck = new Deck(deckName);

        content.split('\n')
            .map(line => line.trim())
            .filter(line => line)
            .forEach(line => {
                const [front, back] = line.split('\t');
                if (front && back) {
                    const card = new Card(front.trim(), back.trim());
                    deck.addCard(card);
                }
            });

        decks[deck.id] = deck;
        saveDecks();

        fileInput.value = '';
        document.getElementById('importDeckName').value = '';
        document.getElementById('importPreview').innerHTML = '';
        hideOverlay('import');
        alert('Import successful!');
    };
    reader.readAsText(file);
}

// Deck management functions
function updateDecksList() {
    const deckList = document.getElementById('deckList');
    deckList.innerHTML = Object.values(decks).map(deck => {
        deck.performMaintenance(); // Run maintenance before showing deck stats
        const dueCards = deck.getDueCards();
        const dueCount = dueCards.length;
        const extraDueCount = dueCards.filter(card => card.extraDue).length;
        const totalCount = Object.keys(deck.cards).length;
        
        return `
            <div class="deck-card" onclick="startStudySession('${deck.id}')">
                <div class="deck-title">${deck.name}</div>
                <div class="deck-stats">
                    <div>Due: ${dueCount}${extraDueCount ? ` (${extraDueCount} overdue)` : ''}</div>
                    <div>Total: ${totalCount}</div>
                    <div>New today: ${deck.newCardsToday}/${MAX_NEW_CARDS_PER_DAY}</div>
                    <div>Reviews today: ${deck.totalReviewsToday}/${MAX_TOTAL_CARDS_PER_DAY}</div>
                </div>
            </div>
        `;
    }).join('');
}

// Study functions
function startStudySession(deckId) {
    currentDeck = decks[deckId];
    studyState.cardsToReview = currentDeck.getDueCards();
    studyState.showingAnswer = false;

    // Reset sessionReviewed flag for all cards
    studyState.cardsToReview.forEach(card => card.sessionReviewed = false);

    if (studyState.cardsToReview.length === 0) {
        const remainingTotal = MAX_TOTAL_CARDS_PER_DAY - currentDeck.totalReviewsToday;
        const remainingNew = MAX_NEW_CARDS_PER_DAY - currentDeck.newCardsToday;
        
        let message = 'No cards due for review!\n\n';
        message += `Reviews today: ${currentDeck.totalReviewsToday}/${MAX_TOTAL_CARDS_PER_DAY}\n`;
        message += `New cards today: ${currentDeck.newCardsToday}/${MAX_NEW_CARDS_PER_DAY}`;
        
        alert(message);
        return;
    }

    currentCard = studyState.cardsToReview[0];
    showOverlay('study');
    displayCurrentCard();
}

function displayCurrentCard() {
    const content = document.getElementById('cardContent');
    const ratingButtons = document.getElementById('ratingButtons');
    const showAnswerBtn = document.getElementById('showAnswerBtn');

    let cardHtml = `<div class="card-front">${currentCard.front}</div>`;
    
    if (studyState.showingAnswer) {
        cardHtml += `<div class="card-back">${currentCard.back}</div>`;
        if (currentCard.extraDue) {
            cardHtml += `<div class="card-overdue">This card is overdue</div>`;
        }
    }
    
    content.innerHTML = cardHtml;

    if (studyState.showingAnswer) {
        ['again', 'hard', 'good', 'easy'].forEach(rating => {
            const preview = currentCard.getIntervalPreview(rating);
            const button = ratingButtons.querySelector(`.rating-${rating}`);
            button.innerHTML = `${rating.charAt(0).toUpperCase() + rating.slice(1)}<br><small>${preview}</small>`;
        });
        
        ratingButtons.style.display = 'flex';
        showAnswerBtn.style.display = 'none';
    } else {
        ratingButtons.style.display = 'none';
        showAnswerBtn.style.display = 'block';
    }
}

function showAnswer() {
    studyState.showingAnswer = true;
    displayCurrentCard();
}

function rateCard(rating) {
    if (!studyState.showingAnswer) return;

    // Update counts only if this is the first review of the card in this session
    if (!currentCard.sessionReviewed) {
        currentDeck.totalReviewsToday++;
        if (currentCard.reviews === 0) {
            currentDeck.newCardsToday++;
        }
        currentCard.sessionReviewed = true;
    }

    const previewInterval = currentCard.getIntervalPreview(rating);
    currentCard.calculateNextInterval(rating);
    currentDeck.lastReview = new Date();
    saveDecks();

    studyState.cardsToReview.shift();

    // Parse the interval preview to check if it's less than 24 hours
    const isMinutes = previewInterval.endsWith('m');
    const isSeconds = previewInterval.endsWith('s');
    const isHours = previewInterval.endsWith('h');
    const value = parseInt(previewInterval);

    if (isSeconds || isMinutes || (isHours && value < 24)) {
        const insertIndex = studyState.cardsToReview.findIndex(card => card.dueDate > currentCard.dueDate);
        if (insertIndex === -1) {
            studyState.cardsToReview.push(currentCard);
        } else {
            studyState.cardsToReview.splice(insertIndex, 0, currentCard);
        }
    }

    if (studyState.cardsToReview.length === 0) {
        hideOverlay('study');
        alert('Review session complete!');
    } else {
        currentCard = studyState.cardsToReview[0];
        studyState.showingAnswer = false;
        displayCurrentCard();
    }
}

// Export function
function exportAllDecks() {
    const exportData = JSON.stringify(decks, null, 2);
    const blob = new Blob([exportData], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'srs_decks.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}
    </script>
</body>