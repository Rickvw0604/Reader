<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SRS Flashcards</title>
    <style>
/* Base Styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: Arial, sans-serif;
    line-height: 1.6;
    background-color: #f5f5f5;
    min-height: 100vh;
}

/* Top Bar */
.top-bar {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: 50px;
    background: #2c3e50;
    color: white;
    display: flex;
    align-items: center;
    padding: 0 20px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    z-index: 1000;
}

/* Container */
.container {
    max-width: 1000px;
    margin: 20px auto 0;
    padding: 20px;
}

/* Home Page */
.home-container {
    text-align: center;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: calc(100vh - 60px);
    margin-top: 50px;
}

.button-grid {
    display: grid;
    gap: 20px;
    grid-template-columns: repeat(2, 1fr);
    margin: 0 auto;
    max-width: 600px;
    width: 90%;
}

.home-button {
    padding: 30px 20px;
    font-size: 1.2em;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    background: #2c3e50;
    color: white;
    transition: transform 0.2s, background 0.2s;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

.home-button:hover {
    transform: translateY(-2px);
    background: #34495e;
}

.deck-card {
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    touch-action: none;
}

/* Overlay Pages */
.overlay-page {
    display: none;
    position: fixed;
    top: 50px;
    left: 0;
    width: 100%;
    height: calc(100% - 50px);
    background: white;
    z-index: 1999;
    overflow-y: auto;
}

.overlay-page.active {
    display: block;
}

/* Study Stats Panel */
.study-stats {
    position: fixed;
    top: 0;
    left: 0;
    background: #2c3e50;
    padding: 15px;
    max-width: 50%;
    height: 50px;
    display: flex;
    align-items: center;
    gap: 15px;
    z-index: 2000;
}

.study-stat-item {
    display: flex;
    align-items: center;
    gap: 3px;
    color: white;
}

.study-stat-item:last-child {
    border-bottom: none;
}

.study-stat-label {
    font-size: 0.9em;
    opacity: 0.9;
}

.study-stat-value {
    font-weight: bold;
}

.close-button {
    position: absolute;
    top: 5px;
    right: 20px;
    background: rgba(44, 62, 80, 0.1);
    border: 2px solid #2c3e50;
    font-size: 24px;
    line-height: 24px;
    cursor: pointer;
    color: #2c3e50;
    z-index: 2001;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s;
}

.close-button:hover {
    background-color: rgba(44, 62, 80, 0.2);
    transform: scale(1.1);
}

/* Deck Grid */
.deck-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 20px;
    margin-top: 20px;
}

.deck-card {
    background: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    cursor: pointer;
    transition: transform 0.2s;
}

.deck-card:hover {
    transform: translateY(-2px);
}

.deck-title {
    font-size: 1.2em;
    margin-bottom: 10px;
    color: #2c3e50;
}

.deck-stats {
    color: #666;
    font-size: 0.9em;
}

/* Create Deck Form */
.create-form {
    background: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    margin-top: 20px;
}

.form-group {
    margin-bottom: 20px;
}

.form-group label {
    display: block;
    margin-bottom: 5px;
    color: #2c3e50;
}

.form-input {
    width: 100%;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 16px;
}

/* Card Creation Area */
.card-creation {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin-top: 20px;
}

.card-side {
    padding: 20px;
    background: #f8f9fa;
    border-radius: 4px;
}

/* Study Interface */
.study-container {
    max-width: 800px;
    margin: 20px auto;
    padding: 20px;
}

/* Card display style */
.card-display {
    background: white;
    padding: 40px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    min-height: 300px;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    align-items: center;
    margin-bottom: 20px;
    font-size: 1.5em;
    padding-top: 80px;
}

.card-front {
    width: 100%;
    text-align: center;
    margin-top: -40px;
    padding: 0;
}

.card-back {
    width: 100%;
    text-align: center;
    padding: 20px;
    border-top: 1px solid #eee;
    margin-top: 10px;
    padding-top: 20px;
}

/* Rating buttons style */
.rating-buttons {
    display: flex;
    gap: 5px;
    justify-content: center;
    padding: 10px;
}

.rating-button {
    padding: 10px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background 0.2s;
    min-width: 70px;
    color: white;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 3px;
    font-size: 0.9em;
}

.rating-again { background: #e74c3c; }
.rating-hard { background: #f39c12; }
.rating-good { background: #2ecc71; }
.rating-easy { background: #3498db; }

.rating-button:hover {
    filter: brightness(1.1);
    transform: translateY(-1px);
}

.button {
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    background: #2c3e50;
    color: white;
    cursor: pointer;
    transition: background 0.2s;
}

.button:hover {
    background: #34495e;
}

/* Import Interface */
.import-container {
    margin-top: 20px;
    background: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.file-input {
    margin: 20px 0;
}

.import-preview {
    margin-top: 20px;
    max-height: 300px;
    overflow-y: auto;
}

.preview-table {
    width: 100%;
    border-collapse: collapse;
}

.preview-table th,
.preview-table td {
    padding: 8px;
    border: 1px solid #ddd;
    text-align: left;
}

.preview-table th {
    background: #f5f5f5;
}
    </style>
</head>
<body>
    <!-- Top Bar -->
    <div class="top-bar">
    </div>

    <!-- Home Page -->
    <div id="homePage" class="page active">
        <div class="home-container">
            <div class="button-grid">
                <button class="home-button" onclick="showOverlay('createDeck')">Create Deck</button>
                <button class="home-button" onclick="showOverlay('import')">Import Cards</button>
                <button class="home-button" onclick="showOverlay('decks')">My Decks</button>
                <button class="home-button" onclick="exportAllDecks()">Export All</button>
            </div>
        </div>
    </div>

    <!-- Create Deck Overlay -->
    <div id="createDeckOverlay" class="overlay-page">
        <button class="close-button" onclick="hideOverlay('createDeck')">&times;</button>
        <div class="container">
            <div class="create-form">
                <div class="form-group">
                    <label for="deckName">Deck Name</label>
                    <input type="text" id="deckName" class="form-input" placeholder="Enter deck name">
                </div>
                <div class="card-creation">
                    <div class="card-side">
                        <label>Front</label>
                        <textarea id="cardFront" class="form-input" rows="4"></textarea>
                    </div>
                    <div class="card-side">
                        <label>Back</label>
                        <textarea id="cardBack" class="form-input" rows="4"></textarea>
                    </div>
                </div>
                <button class="button" onclick="addCard()">Add Card</button>
                <button class="button" onclick="saveDeck()">Save Deck</button>
            </div>
            <div id="cardPreview" class="deck-grid">
                <!-- Added cards will appear here -->
            </div>
        </div>
    </div>

    <!-- Import Overlay -->
    <div id="importOverlay" class="overlay-page">
        <button class="close-button" onclick="hideOverlay('import')">&times;</button>
        <div class="container">
            <div class="import-container">
                <h2>Import Cards</h2>
                <div>
                    <input type="file" id="importFile" accept=".txt,.xlsx" class="file-input" 
                           onchange="handleFileSelect(event)">
                </div>
                <div class="form-group">
                    <label for="importDeckName">Deck Name</label>
                    <input type="text" id="importDeckName" class="form-input" placeholder="Enter deck name">
                </div>
                <div class="import-preview" id="importPreview">
                    <!-- Preview will be shown here -->
                </div>
                <button class="button" onclick="processImport()">Import Cards</button>
            </div>
        </div>
    </div>

    <!-- Decks Overlay -->
    <div id="decksOverlay" class="overlay-page">
        <button class="close-button" onclick="hideOverlay('decks')">&times;</button>
        <div class="container">
            <div id="deckList" class="deck-grid">
                <!-- Decks will be listed here -->
            </div>
        </div>
    </div>

    <!-- Study Overlay -->
    <div id="studyOverlay" class="overlay-page">
        <button class="close-button" onclick="hideOverlay('study')">&times;</button>
        <div class="study-stats" id="studyStats">
            <div class="study-stat-item">
                <span class="study-stat-label">N:</span>
                <span class="study-stat-value" id="newCardsCount">0</span>
            </div>
            <div class="study-stat-item">
                <span class="study-stat-label">L:</span>
                <span class="study-stat-value" id="learningCount">0</span>
            </div>
            <div class="study-stat-item">
                <span class="study-stat-label">R:</span>
                <span class="study-stat-value" id="toReviewCount">0</span>
            </div>
        </div>
        <div class="study-container">
            <div class="card-display">
                <div id="cardContent">
                    <!-- Card content will be inserted here -->
                </div>
            </div>
            <button id="showAnswerBtn" class="button" onclick="showAnswer()">Show Answer</button>
            <div id="ratingButtons" class="rating-buttons" style="display: none;">
                <button class="rating-button rating-again" onclick="rateCard('again')">Again</button>
                <button class="rating-button rating-hard" onclick="rateCard('hard')">Hard</button>
                <button class="rating-button rating-good" onclick="rateCard('good')">Good</button>
                <button class="rating-button rating-easy" onclick="rateCard('easy')">Easy</button>
            </div>
        </div>
    </div>

    <script>
      const urlParams = new URLSearchParams(window.location.search);
const currentDay = parseInt(urlParams.get('day')) || 1;
    // Constants for SRS algorithm
    const LEARNING_STEPS = [1, 10]; // minutes
    const GRADUATING_INTERVAL = 1; // days
    const MINIMUM_INTERVAL = 1;
    const EASY_BONUS = 1.3;
    const INTERVAL_MODIFIER = 1.0;
    const MAX_NEW_CARDS_PER_DAY = 10;  // Maximum new cards per day
    const MAX_TOTAL_CARDS_PER_DAY = 100;  // Maximum total reviews per day

    // Data structures and state
    let decks = {};
    let currentDeck = null;
    let currentCard = null;
    let tempCards = [];
    let longPressTimer;
    const LONG_PRESS_DURATION = 500;
    let isLongPress = false;
    let touchStartPosition;
    let studyState = {
        showingAnswer: false,
        cardsToReview: []
    };

    // Time formatting function
    function formatTimeInterval(minutes) {
        if (minutes < 1) return `${Math.round(minutes * 60)}s`;
        if (minutes < 60) return `${Math.round(minutes)}m`;
        if (minutes < 1440) return `${Math.round(minutes / 60)}h`;
        if (minutes < 525600) return `${Math.round(minutes / 1440)}d`;
        return `${Math.round(minutes / 525600)}y`;
    }

    // Initialize app
    document.addEventListener('DOMContentLoaded', function() {
        loadDecks();
        updateDecksList();
    });
// Card class
    class Card {
        constructor(front, back) {
            this.id = Date.now().toString() + Math.random().toString(36).substr(2, 9);
            this.front = front;
            this.back = back;
            this.interval = 0;
            this.ease = 2.5;
            this.reviews = 0;
            this.lapses = 0;
            this.step = 0;
            this.state = 'new'; // 'new', 'learning', 'review', 'relearning'
            this.dueDate = new Date();
            this.sessionReviewed = false;
            this.extraDue = false;
            this.lastReviewDate = new Date().toISOString();
        }

        calculateNextInterval(rating) {
            const now = new Date();
            let nextDate = new Date();
            let interval;

            switch(this.state) {
                case 'new':
                case 'learning':
                    if (rating === 'again') {
                        this.step = 0;
                        interval = LEARNING_STEPS[0];
                        this.state = 'learning';
                        nextDate.setMinutes(now.getMinutes() + interval);
                    } else if (rating === 'hard') {
                        interval = LEARNING_STEPS[this.step];
                        this.state = 'learning';
                        nextDate.setMinutes(now.getMinutes() + interval);
                    } else if (rating === 'good') {
                        if (this.step < LEARNING_STEPS.length - 1) {
                            this.step++;
                            interval = LEARNING_STEPS[this.step];
                            this.state = 'learning';
                            nextDate.setMinutes(now.getMinutes() + interval);
                        } else {
                            this.state = 'review';
                            interval = GRADUATING_INTERVAL * 1440;
                            nextDate.setMinutes(now.getMinutes() + interval);
                        }
                    } else if (rating === 'easy') {
                        this.state = 'review';
                        interval = GRADUATING_INTERVAL * EASY_BONUS * 1440;
                        nextDate.setMinutes(now.getMinutes() + interval);
                    }
                    break;

                case 'review':
                    if (rating === 'again') {
                        this.state = 'relearning';
                        this.step = 0;
                        this.lapses++;
                        interval = LEARNING_STEPS[0];
                        this.ease = Math.max(1.3, this.ease - 0.2);
                        nextDate.setMinutes(now.getMinutes() + interval);
                    } else {
                        let factor;
                        if (rating === 'hard') {
                            factor = 1.2;
                            this.ease = Math.max(1.3, this.ease - 0.15);
                        } else if (rating === 'good') {
                            factor = this.ease;
                        } else { // easy
                            factor = this.ease * EASY_BONUS;
                            this.ease += 0.15;
                        }
                        interval = this.interval === 0 ? 
                            GRADUATING_INTERVAL * 1440 : 
                            Math.max(MINIMUM_INTERVAL, this.interval * factor) * 1440;
                        nextDate.setMinutes(now.getMinutes() + interval);
                    }
                    break;

                case 'relearning':
                    if (rating === 'again') {
                        interval = LEARNING_STEPS[0];
                        nextDate.setMinutes(now.getMinutes() + interval);
                    } else if (rating === 'good') {
                        this.state = 'review';
                        interval = Math.max(MINIMUM_INTERVAL, Math.round(this.interval / 2)) * 1440;
                        nextDate.setMinutes(now.getMinutes() + interval);
                    } else if (rating === 'easy') {
                        this.state = 'review';
                        interval = this.interval * 1440;
                        nextDate.setMinutes(now.getMinutes() + interval);
                    }
                    break;
            }

            this.interval = interval / 1440; // Convert back to days for storage
            this.dueDate = nextDate;
            this.reviews++;
            this.extraDue = false;
            this.lastReviewDate = now.toISOString();
            return interval;
        }
        
getIntervalPreview(rating) {
            let interval;

            switch(this.state) {
                case 'new':
                case 'learning':
                    if (rating === 'again') {
                        interval = LEARNING_STEPS[0];
                    } else if (rating === 'hard') {
                        interval = LEARNING_STEPS[this.step];
                    } else if (rating === 'good') {
                        interval = this.step < LEARNING_STEPS.length - 1 ? 
                            LEARNING_STEPS[this.step + 1] : 
                            GRADUATING_INTERVAL * 1440;
                    } else if (rating === 'easy') {
                        interval = GRADUATING_INTERVAL * EASY_BONUS * 1440;
                    }
                    break;

                case 'review':
                    if (rating === 'again') {
                        interval = LEARNING_STEPS[0];
                    } else {
                        let factor = rating === 'hard' ? 1.2 :
                                    rating === 'good' ? this.ease :
                                    this.ease * EASY_BONUS;
                        interval = this.interval === 0 ? 
                            GRADUATING_INTERVAL * 1440 : 
                            this.interval * factor * 1440;
                    }
                    break;

                case 'relearning':
                    if (rating === 'again') {
                        interval = LEARNING_STEPS[0];
                    } else if (rating === 'good') {
                        interval = Math.max(MINIMUM_INTERVAL, Math.round(this.interval / 2)) * 1440;
                    } else if (rating === 'easy') {
                        interval = this.interval * 1440;
                    }
                    break;
            }

            return formatTimeInterval(interval);
        }
    }

    // Deck class
    class Deck {
        constructor(name) {
            this.id = Date.now().toString() + Math.random().toString(36).substr(2, 9);
            this.name = name;
            this.cards = {};
            this.created = new Date();
            this.lastReview = null;
            this.newCardsToday = 0;
            this.totalReviewsToday = 0;
            this.lastSyncDate = new Date().toISOString();
            this.lastMaintenanceDate = new Date().toISOString();
        }

        addCard(card) {
            this.cards[card.id] = card;
        }

        performMaintenance() {
            const now = new Date();
            const lastMaintenance = new Date(this.lastMaintenanceDate);
            
            // Check if it's a new day (comparing dates at midnight)
            const lastDate = new Date(lastMaintenance.getFullYear(), lastMaintenance.getMonth(), lastMaintenance.getDate());
            const currentDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            
            if (currentDate > lastDate) {
                // Reset daily counters at midnight
                this.newCardsToday = 0;
                this.totalReviewsToday = 0;
                
                // Calculate days passed since last sync
                const lastSync = new Date(this.lastSyncDate);
                const daysPassed = Math.floor((currentDate - lastSync) / (1000 * 60 * 60 * 24));
                
                // Update card statistics if multiple days have passed
                if (daysPassed > 0) {
                    Object.values(this.cards).forEach(card => {
                        if (card.dueDate > lastSync && card.dueDate < now) {
                            card.extraDue = true;
                        }
                    });
                }
                
                this.lastMaintenanceDate = now.toISOString();
                this.lastSyncDate = now.toISOString();
                saveDecks(); // Save changes to localStorage
            }
        }
getDueCards() {
            this.performMaintenance();
            const now = new Date();
            
            // Get all due cards
            let dueCards = Object.values(this.cards).filter(card => 
                card.dueDate <= now || card.reviews === 0
            );

            // Sort cards
            dueCards.sort((a, b) => {
                const aDueDate = new Date(a.dueDate);
                const bDueDate = new Date(b.dueDate);
                const aIsDue = aDueDate <= now;
                const bIsDue = bDueDate <= now;

                // If either card is a due learning card, it comes first
                if (a.sessionReviewed && aIsDue && !(b.sessionReviewed && bIsDue)) return -1;
                if (b.sessionReviewed && bIsDue && !(a.sessionReviewed && aIsDue)) return 1;

                // Then reviews from previous sessions
                if (a.reviews > 0 && !a.sessionReviewed && b.reviews === 0) return -1;
                if (b.reviews > 0 && !b.sessionReviewed && a.reviews === 0) return 1;

                // Then new cards
                if (a.reviews === 0 && b.sessionReviewed) return -1;
                if (b.reviews === 0 && a.sessionReviewed) return 1;

                // Finally, non-due learning cards
                if (a.sessionReviewed && b.sessionReviewed) {
                    return aDueDate - bDueDate;  // Sort by due date
                }

                return aDueDate - bDueDate;  // Default sort by due date
            });

            // Separate new cards and review cards
            let newCards = dueCards.filter(card => card.reviews === 0);
            let reviewCards = dueCards.filter(card => card.reviews > 0);

            // Limit new cards
            const remainingNewCards = MAX_NEW_CARDS_PER_DAY - this.newCardsToday;
            if (remainingNewCards > 0) {
                newCards = newCards.slice(0, remainingNewCards);
            } else {
                newCards = [];
            }

            // Combine and limit total cards
            dueCards = [...reviewCards, ...newCards];
            const remainingTotal = MAX_TOTAL_CARDS_PER_DAY - this.totalReviewsToday;
            return remainingTotal > 0 ? dueCards.slice(0, remainingTotal) : [];
        }
    }

    // Storage functions
    function loadDecks() {
        const savedDecks = localStorage.getItem('srs_decks');
        if (savedDecks) {
            const parsed = JSON.parse(savedDecks);
            decks = Object.fromEntries(
                Object.entries(parsed).map(([id, deck]) => {
                    const newDeck = new Deck(deck.name);
                    Object.assign(newDeck, {
                        id: deck.id,
                        created: new Date(deck.created),
                        lastReview: deck.lastReview ? new Date(deck.lastReview) : null,
                        newCardsToday: deck.newCardsToday || 0,
                        totalReviewsToday: deck.totalReviewsToday || 0,
                        lastSyncDate: deck.lastSyncDate || new Date().toISOString(),
                        lastMaintenanceDate: deck.lastMaintenanceDate || new Date().toISOString()
                    });
                    
                    Object.values(deck.cards).forEach(cardData => {
                        const card = new Card(cardData.front, cardData.back);
                        Object.assign(card, {
                            ...cardData,
                            dueDate: new Date(cardData.dueDate),
                            lastReviewDate: cardData.lastReviewDate || new Date().toISOString()
                        });
                        newDeck.addCard(card);
                    });
                    
                    return [id, newDeck];
                })
            );
        }
    }

    function saveDecks() {
        localStorage.setItem('srs_decks', JSON.stringify(decks));
    }
// UI functions
    function showOverlay(overlayId) {
        document.querySelectorAll('.overlay-page').forEach(overlay => {
            overlay.classList.remove('active');
        });
        document.getElementById(overlayId + 'Overlay').classList.add('active');

        if (overlayId === 'decks') {
            updateDecksList();
        }
    }

    function hideOverlay(overlayId) {
        document.getElementById(overlayId + 'Overlay').classList.remove('active');
        if (overlayId === 'study') {
            studyState.showingAnswer = false;
            studyState.cardsToReview = [];
            currentCard = null;
        }
    }

    function updateStudyStats() {
        if (!currentDeck || !studyState.cardsToReview) return;

        // New: Never seen before (reviews === 0)
        const newCards = studyState.cardsToReview.filter(card => 
            card.reviews === 0 && !card.sessionReviewed
        ).length;

        // Learning: Cards that were reviewed this session and due within 24h
        const learning = studyState.cardsToReview.filter(card => {
            if (!card.dueDate) return false;
            const dueWithin24h = (new Date(card.dueDate) - new Date()) <= 24 * 60 * 60 * 1000;
            return card.state === 'learning' && card.sessionReviewed;
        }).length;

        // Review: Due cards from previous sessions (not new, not learning)
        const toReview = studyState.cardsToReview.filter(card => 
            card.reviews > 0 && !card.sessionReviewed
        ).length;

        document.getElementById('newCardsCount').textContent = newCards;
        document.getElementById('learningCount').textContent = learning;
        document.getElementById('toReviewCount').textContent = toReview;
    }

    // Deck creation functions
    function addCard() {
        const front = document.getElementById('cardFront').value.trim();
        const back = document.getElementById('cardBack').value.trim();

        if (!front || !back) {
            alert('Both front and back are required');
            return;
        }

        const card = new Card(front, back);
        tempCards.push(card);
        
        document.getElementById('cardFront').value = '';
        document.getElementById('cardBack').value = '';

        updateCardPreview();
    }

    function updateCardPreview() {
        const preview = document.getElementById('cardPreview');
        preview.innerHTML = tempCards.map((card, index) => `
            <div class="deck-card">
                <div class="deck-title">Card ${index + 1}</div>
                <div class="deck-stats">
                    <div>Front: ${card.front}</div>
                    <div>Back: ${card.back}</div>
                </div>
                <button class="button" onclick="removeCard(${index})">Remove</button>
            </div>
        `).join('');
    }

    function removeCard(index) {
        tempCards.splice(index, 1);
        updateCardPreview();
    }

    function saveDeck() {
        const name = document.getElementById('deckName').value.trim();
        
        if (!name) {
            alert('Please enter a deck name');
            return;
        }

        if (tempCards.length === 0) {
            alert('Please add at least one card');
            return;
        }

        const deck = new Deck(name);
        tempCards.forEach(card => deck.addCard(card));
        
        decks[deck.id] = deck;
        saveDecks();

        tempCards = [];
        document.getElementById('deckName').value = '';
        document.getElementById('cardPreview').innerHTML = '';
        hideOverlay('createDeck');
    }
// Import functions
    function handleFileSelect(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(e) {
            showImportPreview(e.target.result);
        };
        reader.readAsText(file);
    }

    function showImportPreview(content) {
        const lines = content.split('\n')
            .map(line => line.trim())
            .filter(line => line);

        const preview = document.getElementById('importPreview');
        preview.innerHTML = `
            <table class="preview-table">
                <thead>
                    <tr><th>Front</th><th>Back</th></tr>
                </thead>
                <tbody>
                    ${lines.map(line => {
                        const [front, back] = line.split('\t');
                        return `<tr><td>${front}</td><td>${back}</td></tr>`;
                    }).join('')}
                </tbody>
            </table>
        `;
    }

    function processImport() {
        const deckName = document.getElementById('importDeckName').value.trim();
        const fileInput = document.getElementById('importFile');
        const file = fileInput.files[0];

        if (!deckName || !file) {
            alert('Please provide both deck name and file');
            return;
        }

        const reader = new FileReader();
        reader.onload = function(e) {
            const content = e.target.result;
            const deck = new Deck(deckName);

            content.split('\n')
                .map(line => line.trim())
                .filter(line => line)
                .forEach(line => {
                    const [front, back] = line.split('\t');
                    if (front && back) {
                        const card = new Card(front.trim(), back.trim());
                        deck.addCard(card);
                    }
                });

            decks[deck.id] = deck;
            saveDecks();
            updateDecksList();

            fileInput.value = '';
            document.getElementById('importDeckName').value = '';
            document.getElementById('importPreview').innerHTML = '';
            hideOverlay('import');
            showOverlay('decks');
            alert('Import successful!');
        };
        reader.readAsText(file);
    }

    function updateDecksList() {
        const deckList = document.getElementById('deckList');
        deckList.innerHTML = Object.values(decks).map(deck => {
            deck.performMaintenance();
            const dueCards = deck.getDueCards();
            const totalCount = Object.keys(deck.cards).length;
            
            // Count cards by their state
            const newCards = dueCards.filter(card => card.reviews === 0).length;
            const learning = dueCards.filter(card => 
                card.state === 'learning' || card.state === 'relearning'
            ).length;
            const toReview = dueCards.filter(card => 
                card.state === 'review'
            ).length;
            
            return `
                <div class="deck-card" 
                    onmousedown="handleMouseDown(event, '${deck.id}')"
                    onmouseup="handleMouseUp(event, '${deck.id}')"
                    onmouseleave="cancelLongPress()"
                    ontouchstart="handleTouchStart(event, '${deck.id}')"
                    ontouchend="handleTouchEnd(event, '${deck.id}')"
                    ontouchcancel="cancelLongPress()">
                    <div class="deck-title">${deck.name}</div>
                    <div class="deck-stats">
                        <div>New Cards: ${newCards}</div>
                        <div>Learning: ${learning}</div>
                        <div>To Be Reviewed: ${toReview}</div>
                        <div>Total: ${totalCount}</div>
                    </div>
                </div>
            `;
        }).join('');
    }
// Touch and Mouse Event Handlers
    function handleTouchStart(e, deckId) {
        touchStartPosition = {
            x: e.touches[0].clientX,
            y: e.touches[0].clientY
        };
        isLongPress = false;
        startLongPress(deckId);
    }

    function handleTouchEnd(e, deckId) {
        const touchEndPosition = {
            x: e.changedTouches[0].clientX,
            y: e.changedTouches[0].clientY
        };
        
        // Calculate if there was significant movement
        const moveThreshold = 10; // pixels
        const moved = Math.abs(touchEndPosition.x - touchStartPosition.x) > moveThreshold ||
                     Math.abs(touchEndPosition.y - touchStartPosition.y) > moveThreshold;
        
        cancelLongPress();
        
        // If there wasn't significant movement and it wasn't a long press, treat as click
        if (!moved && !isLongPress) {
            startStudySession(deckId);
        }
    }

    function handleMouseDown(e, deckId) {
        if (e.button === 0) { // Left click only
            isLongPress = false;
            startLongPress(deckId);
        }
    }

    function handleMouseUp(e, deckId) {
        cancelLongPress();
        if (!isLongPress) {
            startStudySession(deckId);
        }
    }

    function startLongPress(deckId) {
        longPressTimer = setTimeout(() => {
            isLongPress = true;
            showDeleteConfirmation(deckId);
        }, LONG_PRESS_DURATION);
    }

    function cancelLongPress() {
        clearTimeout(longPressTimer);
    }

    function showDeleteConfirmation(deckId) {
        const deck = decks[deckId];
        if (confirm(`Are you sure you want to delete the deck "${deck.name}"? This action cannot be undone.`)) {
            deleteDeck(deckId);
        }
    }

    function deleteDeck(deckId) {
        delete decks[deckId];
        saveDecks();
        updateDecksList();
    }

    // Study functions
    function startStudySession(deckId) {
        currentDeck = decks[deckId];
        studyState.cardsToReview = currentDeck.getDueCards();
        studyState.showingAnswer = false;

        studyState.cardsToReview.forEach(card => card.sessionReviewed = false);

        if (studyState.cardsToReview.length === 0) {
            const remainingTotal = MAX_TOTAL_CARDS_PER_DAY - currentDeck.totalReviewsToday;
            const remainingNew = MAX_NEW_CARDS_PER_DAY - currentDeck.newCardsToday;
            
            let message = 'No cards due for review!\n\n';
            message += `Reviews today: ${currentDeck.totalReviewsToday}/${MAX_TOTAL_CARDS_PER_DAY}\n`;
            message += `New cards today: ${currentDeck.newCardsToday}/${MAX_NEW_CARDS_PER_DAY}`;
            
            alert(message);
            return;
        }

        currentCard = studyState.cardsToReview[0];
        showOverlay('study');
        displayCurrentCard();
        updateStudyStats();
    }

    function displayCurrentCard() {
        const content = document.getElementById('cardContent');
        const ratingButtons = document.getElementById('ratingButtons');
        const showAnswerBtn = document.getElementById('showAnswerBtn');

        content.innerHTML = `
            <div class="card-front">${currentCard.front}</div>
            ${studyState.showingAnswer ? `
                <div class="card-back">${currentCard.back}</div>
                ${currentCard.extraDue ? `<div class="card-overdue">This card is overdue</div>` : ''}
            ` : ''}
        `;

        if (studyState.showingAnswer) {
            ['again', 'hard', 'good', 'easy'].forEach(rating => {
                const preview = currentCard.getIntervalPreview(rating);
                const button = ratingButtons.querySelector(`.rating-${rating}`);
                button.innerHTML = `${rating.charAt(0).toUpperCase() + rating.slice(1)}<br><small>${preview}</small>`;
            });
            
            ratingButtons.style.display = 'flex';
            showAnswerBtn.style.display = 'none';
        } else {
            ratingButtons.style.display = 'none';
            showAnswerBtn.style.display = 'block';
        }
    }

    function showAnswer() {
        studyState.showingAnswer = true;
        displayCurrentCard();
    }

    function rateCard(rating) {
        if (!studyState.showingAnswer) return;

        if (!currentCard.sessionReviewed) {
            currentDeck.totalReviewsToday++;
            if (currentCard.reviews === 0) {
                currentDeck.newCardsToday++;
            }
            currentCard.sessionReviewed = true;
        }

        const previewInterval = currentCard.getIntervalPreview(rating);
        currentCard.calculateNextInterval(rating);
        currentDeck.lastReview = new Date();
        saveDecks();

        studyState.cardsToReview.shift();

        // Only reinsert card if it's in learning/relearning state AND interval is less than 24 hours
        const shouldReinsert = (currentCard.state === 'learning' || currentCard.state === 'relearning') &&
                             (previewInterval.endsWith('s') || previewInterval.endsWith('m') || 
                             (previewInterval.endsWith('h') && parseInt(previewInterval) < 24));

        if (shouldReinsert) {
            const insertIndex = studyState.cardsToReview.findIndex(card => card.dueDate > currentCard.dueDate);
            if (insertIndex === -1) {
                studyState.cardsToReview.push(currentCard);
            } else {
                studyState.cardsToReview.splice(insertIndex, 0, currentCard);
            }
        }

        if (studyState.cardsToReview.length === 0) {
    const modal = document.createElement('div');
    modal.style.position = 'fixed';
    modal.style.top = '0';
    modal.style.left = '0';
    modal.style.width = '100%';
    modal.style.height = '100%';
    modal.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
    modal.style.display = 'flex';
    modal.style.justifyContent = 'center';
    modal.style.alignItems = 'center';
    modal.style.zIndex = '3000';

    const modalContent = document.createElement('div');
    modalContent.style.background = 'white';
    modalContent.style.padding = '30px';
    modalContent.style.borderRadius = '8px';
    modalContent.style.textAlign = 'center';
    modalContent.innerHTML = `
        <h2>Review Session Complete!</h2>
        <p>Great job! ðŸŽ‰</p>
        <button class="button" onclick="notifyCompletion()" style="margin-top: 20px;">Complete & Continue</button>
    `;

    modal.appendChild(modalContent);
    document.body.appendChild(modal);
        } else {
            currentCard = studyState.cardsToReview[0];
            studyState.showingAnswer = false;
            displayCurrentCard();
            updateStudyStats();
        }
    }

    // Export function
    function exportAllDecks() {
        const exportData = JSON.stringify(decks, null, 2);
        const blob = new Blob([exportData], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'srs_decks.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
    
    function notifyCompletion() {
    window.parent.postMessage({
        type: 'exerciseComplete',
        exercise: 'anki',
        day: currentDay
    }, '*');
}
    </script>
</body>
</html>