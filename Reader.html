<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Language Learning Text Reader</title>
   <style>
       /* Existing styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: Arial, sans-serif;
    line-height: 1.6;
    background-color: #f5f5f5;
    min-height: 100%;  /* This will reference the iframe's height instead */
    height: 100%;
}

/* Top Bar Styles - Modified for all pages */
.top-bar {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: 50px;
    background: #2c3e50;
    color: white;
    display: flex;
    align-items: center;
    padding: 0 20px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    z-index: 3000;
}

/* Remove top bar hiding */
body .page#readPage.active ~ .top-bar {
    display: flex !important;
}

/* Overlay Styles */
.overlay-page {
    display: none;
    position: fixed;
    top: 50px;
    left: 0;
    width: 100%;
    height: calc(100vh - 50px);
    background: white;
    z-index: 1000;
    overflow-y: auto;
}

.overlay-page.active {
    display: block;
}

.close-button {
    position: fixed;
    top: 45px;
    left: 20px;
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    color: #333;
    z-index: 2999;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
}

.close-button:hover {
    background: #f5f5f5;
}

.rating-button {
    width: 45px;
    height: 45px;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    font-size: 18px;
    font-weight: bold;
    transition: transform 0.2s;
    color: #333;
}

/* Add this new style */
.rating-button.selected {
    border: 3px solid black;
}

.floating-done-button {
    position: fixed;
    background: #2c3e50;
    color: white;
    padding: 8px 16px;
    border-radius: 20px;
    cursor: pointer;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    z-index: 3000;
    font-size: 14px;
    transition: transform 0.1s;
    user-select: none;
}

.floating-done-button:hover {
    transform: scale(1.05);
}

.word-selected {
    outline: 2px solid #2c3e50;
    border-radius: 4px;
}

/* Specific styles for read modal */
#readPage .container {
    max-width: 98%;
    margin: 80px auto;
    padding: 0;
    overflow: hidden;
}

#readPage.overlay-page {
    overflow: hidden;
}

#readPage .text-display-container {
    background: white;
    padding: 10px 20px;
    border-radius: 0;
    box-shadow: none;
    margin-top: 10px;
    min-height: calc(100vh - 100px);
    overflow: hidden;
}

#readPage .page-content {
    min-height: calc(100vh - 120px);
    line-height: 1.6;
    margin: 0;
    overflow: hidden;
}

#textDisplay {
    user-select: none;
    -webkit-user-select: none;  /* Safari */
    -moz-user-select: none;     /* Firefox */
    -ms-user-select: none;      /* IE10+/Edge */
}

#readPage #textDisplay {
    font-size: 18px;
    line-height: 1.6;
    color: #333;
    padding: 0;
    margin: 0;
    overflow: hidden;
}

/* Hide title in reading modal */
#readPage .text-title {
    display: none;
}

.first-page .text-title {
    display: none;
}

.known-words-counter {
    font-size: 16px;
    font-weight: bold;
}

.top-buttons {
    display: none;
}

.top-buttons.visible {
    display: flex;
}

.nav-button {
    background: #34495e;
    color: white;
    border: none;
    padding: 5px 15px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.2s;
}

.nav-button:hover {
    background: #435d78;
}

/* Container Styles */
.container {
    max-width: 1000px;
    margin: 60px auto 0;
    padding: 20px;
    padding-bottom: 80px;
    height: calc(100vh - 110px);
    overflow-y: auto;
}

.bottom-nav {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    height: 60px;
    background: white;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 20px;
    box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
    z-index: 1000;
}

.bottom-nav .nav-button {
    flex: 1;
    margin: 0 10px;
    height: 40px;
    background: #2c3e50;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.2s;
}

.bottom-nav .nav-button:first-child {
    margin-left: 0;
}

.bottom-nav .nav-button:last-child {
    margin-right: 0;
}

/* Home Page Styles */
.home-container {
    text-align: center;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: calc(100vh - 60px);
}

.home-title {
    color: #2c3e50;
    margin-bottom: 40px;
    font-size: 2.5em;
}

.button-grid {
    display: grid;
    gap: 20px;
    grid-template-columns: 1fr 1fr;
    margin: 0 auto;
    max-width: 600px;
    width: 90%;
}

.home-button {
    padding: 30px 20px;
    font-size: 1.2em;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    background: #2c3e50;
    color: white;
    transition: transform 0.2s, background 0.2s;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

.home-button:hover {
    transform: translateY(-2px);
    background: #34495e;
}

.home-button:active {
    transform: translateY(0);
}

/* Create Text Page Styles */
.create-container {
    background: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.title-input-container {
    margin-bottom: 20px;
}

.text-title-input {
    width: 100%;
    padding: 12px 15px;
    font-size: 18px;
    border: 1px solid #ddd;
    border-radius: 4px;
    margin-bottom: 10px;
    font-weight: bold;
}

.text-title-input:focus {
    outline: none;
    border-color: #2c3e50;
    box-shadow: 0 0 0 2px rgba(44, 62, 80, 0.1);
}

.text-title-input.error {
    border-color: #e74c3c;
}

.error-message {
    color: #e74c3c;
    font-size: 14px;
    margin-top: 5px;
    display: none;
}

.error-message.visible {
    display: block;
}

#textInput {
    width: 100%;
    height: 400px;
    margin-bottom: 20px;
    padding: 15px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 16px;
    line-height: 1.5;
    resize: vertical;
}

.button-container {
    display: flex;
    gap: 10px;
}

.action-button {
    padding: 10px 20px;
    font-size: 1em;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background 0.2s;
}

.save-button {
    background: #4CAF50;
    color: white;
}

.save-button:hover {
    background: #45a049;
}

.cancel-button {
    background: #e74c3c;
    color: white;
}

.cancel-button:hover {
    background: #c0392b;
}

/* Pagination Styles */
.pagination-controls {
    position: fixed;
    top: 50px;
    left: 0;
    right: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 5px 0;
    background: white;
    z-index: 99;
    border-bottom: 1px solid #eee;
}

.pagination-controls span {
    color: #666;
    font-size: 14px;
    display: inline-block;
}

/* Word knowledge levels */
.word-new { background-color: #a8d5ff; }
.word-untracked { background-color: transparent;}
.word-level-1 { background-color: #fff176; }
.word-level-2 { background-color: #ffd54f; }
.word-level-3 { background-color: #ffb300; }
.word-level-4 { background-color: #c5e1a5; }
.word-level-5 { background-color: #81c784; }

/* Rating Overlay Styles */
.rating-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.7);
    z-index: 2001;
}

.rating-box {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    padding: 25px;
    border-radius: 8px;
    text-align: center;
    min-width: 300px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

.selected-word {
    font-size: 24px;
    margin-bottom: 10px;
    padding: 10px;
    background: #f5f5f5;
    border-radius: 4px;
    font-weight: bold;
}

.definition-section {
    margin: 15px 0;
}

.suggested-translation {
    margin-bottom: 10px;
    font-style: italic;
}

.custom-definition {
    width: 100%;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    margin-top: 5px;
}

.rating-buttons {
    display: flex;
    justify-content: center;
    gap: 15px;
    margin: 20px 0;
}

.rating-button {
    width: 45px;
    height: 45px;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    font-size: 18px;
    font-weight: bold;
    transition: transform 0.2s;
    color: #333;
}

.rating-button:hover {
    transform: scale(1.1);
}

.rating-button.level-1 { background-color: #fff176; }
.rating-button.level-2 { background-color: #ffd54f; }
.rating-button.level-3 { background-color: #ffb300; }
.rating-button.level-4 { background-color: #c5e1a5; }
.rating-button.level-5 { background-color: #81c784; }

/* Text Library Styles */
.text-library {
    background: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.text-library .action-button {
    background: #3498db;
    color: white;
    border: none;
    padding: 5px 10px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    margin-right: 5px;
}

.text-library .action-button:hover {
    background: #2980b9;
}

.text-library .action-button:last-child {
    background: #e74c3c;
}

.text-library .action-button:last-child:hover {
    background: #c0392b;
}

/* Sentence Mode Styles */
.sentence-mode-overlay {
    display: none;
    position: fixed;
    top: 50px;
    left: 0;
    width: 100%;
    height: calc(100% - 50px);
    background: white;
    z-index: 2000;
    padding: 20px;
}

.sentence-box {
    height: 100%;
    padding: 60px 20px 20px 20px;
    overflow-y: auto;
}

.sentence-section {
    margin-bottom: 30px;
}

.sentence-section h3 {
    font-size: 18px;
    margin-bottom: 15px;
    color: #2c3e50;
}

.translation-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.sentence-content {
    font-size: 20px;
    line-height: 1.6;
    min-height: 50px;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
}

.sentence-translation {
    font-size: 18px;
    color: #666;
    margin: 10px 0;
    font-style: italic;
    padding: 10px;
}

.translation-section.hidden .sentence-translation {
    display: none;
}

.sentence-close {
    position: fixed;
    top: 45px;
    left: 20px;
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    color: #333;
    padding: 10px;
    border-radius: 4px;
    z-index: 2999;
}

.sentence-close:hover {
    background: #f5f5f5;
}

.nav-arrow {
    background: #2c3e50;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    transition: background 0.2s, transform 0.1s;
    min-width: 120px;
}

.nav-arrow:hover {
    background: #34495e;
    transform: translateY(-1px);
}

.nav-arrow:active {
    transform: translateY(0);
}

#sentenceCounter {
    color: #666;
    font-size: 14px;
    padding: 0 20px;
    flex: 0 0 auto;
}

.sentence-navigation {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px;
    background: #f8f9fa;
    border-top: 1px solid #e9ecef;
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 2002;
    box-shadow: 0 -2px 4px rgba(0,0,0,0.1);
}

/* Adjust sentence box to account for fixed navigation */
.sentence-box {
    padding-bottom: 100px;
    height: 100%;
    overflow-y: auto;
}

.dont-track-button {
    background: #e74c3c;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 16px;
    transition: background 0.2s;
    margin-top: 10px;
}

.dont-track-button:hover {
    background: #c0392b;
}

.mark-new-button {
    background: #4CAF50;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 16px;
    transition: background 0.2s;
}

.mark-new-button:hover {
    background: #45a049;
}

/* File input styles */
.file-input {
    display: none;
}

/* Page visibility styles */
.page {
    display: none;
}

.page.active {
    display: block;
}

/* Status message styles */
.status-message {
    position: fixed;
    bottom: 20px;
    right: 20px;
    padding: 10px 20px;
    background: #2c3e50;
    color: white;
    border-radius: 4px;
    display: none;
    z-index: 3000;
}

/* Sentence highlighting in text */
.sentence-highlight {
    background-color: rgba(231, 76, 60, 0.2);
    border-radius: 4px;
}

/* Modified container style for overlays */
.overlay-page .container {
    margin-top: 20px;
    padding: 20px;
}

/* Bottom nav modification */
.bottom-nav {
    display: none;
}

#readPage .bottom-nav {
    display: flex;
}

/* Vocabulary table styles */
.vocabulary-table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 20px;
}

.vocabulary-table th,
.vocabulary-table td {
    padding: 12px;
    border: 1px solid #ddd;
    text-align: left;
}

.vocabulary-table th {
    background: #f5f5f5;
}

/* Search and filter styles */
.search-input {
    width: 100%;
    padding: 8px;
    margin-bottom: 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
}

.level-filter {
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    margin-bottom: 20px;
}

/* Audio-related styles - Add at the end of your existing styles */
.text-selection-modal {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    padding: 25px;
    border-radius: 8px;
    width: 90%;
    max-width: 600px;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    z-index: 3000;
}

.text-selection-list {
    margin: 20px 0;
    border: 1px solid #ddd;
    border-radius: 4px;
    max-height: 400px;
    overflow-y: auto;
}

.text-selection-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px;
    border-bottom: 1px solid #eee;
    cursor: pointer;
    transition: background 0.2s;
}

.text-selection-item:last-child {
    border-bottom: none;
}

.text-selection-item:hover {
    background: #f5f5f5;
}

.text-selection-item.has-audio {
    background: #e8f5e9;
}

.text-info {
    flex: 1;
}

.text-title {
    font-weight: bold;
    margin-bottom: 5px;
}

.text-date {
    font-size: 12px;
    color: #666;
}

.audio-status {
    font-size: 12px;
    color: #666;
    font-style: italic;
}

.timestamp-editor {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    z-index: 3000;
    width: 90%;
    max-width: 600px;
    max-height: 80vh;
    overflow-y: auto;
}

.timestamp-row {
    display: flex;
    align-items: center;
    gap: 10px;
    margin: 10px 0;
    padding: 10px;
    background: #f8f9fa;
    border-radius: 4px;
}

.timestamp-text {
    flex: 1;
}

.timestamp-input {
    width: 100px;
    padding: 5px;
}

.audio-controls {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px;
    background: #f5f5f5;
    border-radius: 4px;
    margin: 10px 0;
}

.audio-progress {
    flex: 1;
    height: 4px;
    background: #ddd;
    border-radius: 2px;
    cursor: pointer;
}

.audio-progress-fill {
    height: 100%;
    background: #2c3e50;
    border-radius: 2px;
    width: 0%;
}

    </style>
</head>
<body>
    <!-- Top Bar - Simplified -->
    <div class="top-bar">
        <div class="known-words-counter">Known Words: <span id="knownWordsCount">0</span></div>
    </div>

  <!-- Home Page -->
<div id="homePage" class="page active">
    <div class="home-container">
        <div class="button-grid">
            <input type="file" id="loadTextInput" class="file-input" accept=".txt">
            <input type="file" id="loadVocabInput" class="file-input" accept=".json">
            <input type="file" id="loadAudioInput" class="file-input" accept="audio/*">
            
            <button class="home-button" onclick="document.getElementById('loadTextInput').click()">
                Load Text
            </button>
            <button class="home-button" onclick="showPage('create')">
                Create Text
            </button>
            <button class="home-button" onclick="saveVocabulary()">
                Save Vocabulary
            </button>
            <button class="home-button" onclick="document.getElementById('loadVocabInput').click()">
                Load Vocabulary
            </button>
            <button class="home-button" onclick="showVocabularyOverview()">
                View Vocabulary List
            </button>
            <button class="home-button" onclick="showTextLibrary()">
                My Texts
            </button>
            <button class="home-button" onclick="showTextSelection()">
                Add Audio to Text
            </button>
        </div>
    </div>
</div>
    
    <!-- Create Text Overlay -->
    <div id="createPage" class="overlay-page">
        <button class="close-button" onclick="showPage('home')">×</button>
        <div class="container">
            <div class="create-container">
                <div class="title-input-container">
                    <input type="text" 
                           id="textTitle" 
                           placeholder="Enter title for your text..." 
                           class="text-title-input"
                           required>
                </div>
                <textarea id="textInput" placeholder="Write or paste your text here..."></textarea>
                <div class="button-container">
                    <button class="action-button save-button" onclick="saveAndRead()">Save & Continue to Reading</button>
                    <button class="action-button cancel-button" onclick="showPage('home')">Cancel</button>
                </div>
            </div>
        </div>
    </div>

   <div id="readPage" class="overlay-page">
    <button class="close-button" onclick="showPage('home')">×</button>
    <div class="container">
        <div class="text-display-container">
            <h2 id="textDisplayTitle" class="text-title"></h2>
            <!-- Add this new div -->
            <div class="audio-controls">
                <button onclick="playPauseAudio()">Play/Pause</button>
                <div class="audio-progress">
                    <div class="audio-progress-fill"></div>
                </div>
                <span id="currentTime">0:00</span>
            </div>
            <!-- End of new div -->
            <div id="textDisplay"></div>
        </div>
    </div>
    <div class="bottom-nav">
        <button class="nav-button" onclick="changePage(-1)">Previous</button>
        <button class="nav-button sentence-mode-toggle" onclick="toggleSentenceMode()">Sentence Mode</button>
        <button class="nav-button" onclick="changePage(1)">Next</button>
    </div>
</div>

    <!-- Text Library Overlay -->
    <div id="textLibraryPage" class="overlay-page">
        <button class="close-button" onclick="showPage('home')">×</button>
        <div class="container">
            <div class="text-library">
                <h2 class="overview-title">My Texts</h2>
                <div class="filter-section">
                    <input type="text" id="textSearch" placeholder="Search texts..." class="search-input">
                </div>
                <table id="textLibraryTable" class="vocabulary-table">
                    <thead>
                        <tr>
                            <th>Title</th>
                            <th>Date Added</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Vocabulary Overview Overlay -->
    <div id="vocabularyOverviewPage" class="overlay-page">
        <button class="close-button" onclick="showPage('home')">×</button>
        <div class="container">
            <div class="vocabulary-overview">
                <h2 class="overview-title">Vocabulary Overview</h2>
                <div class="filter-section">
                    <input type="text" id="vocabularySearch" placeholder="Search words..." class="search-input">
                    <select id="levelFilter" class="level-filter">
                        <option value="all">All Levels</option>
                        <option value="0">New Words</option>
                        <option value="1">Level 1</option>
                        <option value="2">Level 2</option>
                        <option value="3">Level 3</option>
                        <option value="4">Level 4</option>
                        <option value="5">Level 5</option>
                    </select>
                </div>
                <table id="vocabularyTable" class="vocabulary-table">
                    <thead>
                        <tr>
                            <th>Spanish Word</th>
                            <th>Translation</th>
                            <th>Level</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>
     <!-- Word Rating Modal -->
    <div id="ratingOverlay" class="rating-overlay">
        <div class="rating-box">
            <div class="selected-word"></div>
            <div class="definition-section">
                <div class="suggested-translation">Suggested: <span class="word-translation">Translating...</span></div>
                <input type="text" class="custom-definition" placeholder="Enter custom definition (optional)">
            </div>
            <div>Rate how well you know this word:</div>
            <div class="rating-buttons">
                <button class="rating-button level-1" onclick="rateWord(1)">1</button>
                <button class="rating-button level-2" onclick="rateWord(2)">2</button>
                <button class="rating-button level-3" onclick="rateWord(3)">3</button>
                <button class="rating-button level-4" onclick="rateWord(4)">4</button>
                <button class="rating-button level-5" onclick="rateWord(5)">5</button>
            </div>
           <button class="dont-track-button" onclick="markAsUntracked()">Don't add to vocabulary</button>
        </div>
    </div>

    <!-- Sentence Mode Overlay -->
    <div id="sentenceModeOverlay" class="sentence-mode-overlay">
        <button class="close-button" onclick="closeSentenceMode()">×</button>
        <div class="sentence-box">
            <div class="sentence-section">
                <h3>Spanish</h3>
                <div class="sentence-audio-controls">
                <button onclick="playSentenceAudio()">Play Audio</button>
            </div>
                <div class="sentence-content"></div>
            </div>
            
            <div class="sentence-section translation-section">
                <div class="translation-header">
                    <h3>English</h3>
                    <button class="toggle-translation-btn" onclick="toggleTranslation()">
                        <span class="toggle-icon">👁️</span>
                    </button>
                </div>
                <div class="sentence-translation"></div>
            </div>

            <div class="sentence-navigation">
                <button class="nav-arrow" onclick="navigateSentence(-1)">
                    ← Previous
                </button>
                <span id="sentenceCounter"></span>
                <button class="nav-arrow" onclick="navigateSentence(1)">
                    Next →
                </button>
            </div>
        </div>
    </div>
    
        <!-- Status Message -->
    <div id="statusMessage" class="status-message"></div>
    
   <!-- Floating Done Button -->
<div id="floatingDone" class="floating-done-button" style="display: none;">
    Done (<span id="selectedCount">0</span>)
</div>

<!-- Text Selection Modal -->
<div id="textSelectionModal" class="text-selection-modal">
    <h3>Select Text to Add Audio</h3>
    <input type="text" 
           class="search-input" 
           id="textSearchAudio" 
           placeholder="Search texts...">
    <div class="text-selection-list" id="textSelectionList">
        <!-- Text items will be populated here -->
    </div>
    <div class="button-container">
        <button class="action-button cancel-button" onclick="closeTextSelection()">Cancel</button>
    </div>
</div>

<!-- Timestamp Editor -->
<div id="timestampEditor" class="timestamp-editor">
    <h3>Synchronize Audio with Text</h3>
    <div class="audio-controls">
        <button onclick="playPauseAudio()">Play/Pause</button>
        <button onclick="seekAudio(-2)">-2s</button>
        <button onclick="seekAudio(2)">+2s</button>
        <span id="currentTime">0:00</span> / <span id="duration">0:00</span>
    </div>
    <div id="timestampRows"></div>
    <button onclick="saveTimestamps()">Save Timestamps</button>
    <button onclick="closeTimestampEditor()">Cancel</button>
</div>
   
    <script>
      const urlParams = new URLSearchParams(window.location.search);
const currentDay = parseInt(urlParams.get('day')) || 1;
// Global variables
let vocabulary = {};
let textLibrary = {};
let currentWord = null;
let currentElement = null;
let sentenceMode = false;
let sentences = [];
let currentSentenceIndex = 0;
let lastClickedSentenceIndex = 0;
let currentOverlayWord = null;
let currentOverlayElement = null;
let translationVisible = false;
let currentPage = 0;
let pages = [];
let touchStartX = null;
let touchEndX = null;
let audioElement = null;
let timestamps = {};
let currentAudioFile = null;
let selectedTextId = null;
let isMultiSelectMode = false;
let selectedWords = new Set();
let longPressTimeout;
let initialX, initialY;
let isPlaying = false;
let currentAudioInterval;

const SWIPE_THRESHOLD = 50;
const CHARS_PER_PAGE = 450;

// Initialize app
document.addEventListener('DOMContentLoaded', function() {
    loadVocabulary();
    loadTextLibrary();
    setupEventListeners();
    
    document.getElementById('loadAudioInput').addEventListener('change', handleAudioUpload);
    document.getElementById('textSearchAudio')?.addEventListener('input', updateTextSelectionList);

    window.addEventListener('click', function(e) {
        const textSelectionModal = document.getElementById('textSelectionModal');
        if (e.target === textSelectionModal) {
            closeTextSelection();
        }
    });

    const draftText = localStorage.getItem('draftText');
    if (draftText) {
        try {
            const draft = JSON.parse(draftText);
            document.getElementById('textInput').value = draft.content || '';
            document.getElementById('textTitle').value = draft.title || '';
        } catch (e) {
            document.getElementById('textInput').value = draftText;
        }
    }
});

// Event Listener Setup
function setupEventListeners() {
    // File input handlers
    document.getElementById('loadTextInput').addEventListener('change', handleTextFileUpload);
    document.getElementById('loadVocabInput').addEventListener('change', handleVocabFileUpload);

    // Multi-select mode handlers
    const doneButton = document.getElementById('floatingDone');
    doneButton.addEventListener('click', handleDoneButtonClick);

    // Mouse events for desktop
    document.addEventListener('mousedown', handleMouseDown);
    document.addEventListener('mouseup', () => clearTimeout(longPressTimeout));
    document.addEventListener('mousemove', handleMouseMove);

    // Touch events for mobile
    document.addEventListener('touchstart', handleTouchStart);
    document.addEventListener('touchend', () => clearTimeout(longPressTimeout));
    document.addEventListener('touchmove', handleTouchMove);

    // Escape key to cancel multi-select
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && isMultiSelectMode) {
            endMultiSelect();
        }
    });

    // Click outside to cancel multi-select
    document.addEventListener('click', (e) => {
        if (isMultiSelectMode && 
            !e.target.closest('span[onclick]') && 
            !e.target.closest('.floating-done-button')) {
            endMultiSelect();
        }
    });

    // Search and filter handlers
    document.getElementById('vocabularySearch')?.addEventListener('input', updateVocabularyTable);
    document.getElementById('levelFilter')?.addEventListener('change', updateVocabularyTable);
    document.getElementById('textSearch')?.addEventListener('input', updateTextLibraryTable);

    // Add swipe navigation setup
    setupSwipeListeners();

    // Keyboard shortcuts
    setupKeyboardShortcuts();
    
    // Rating overlay click handler
    document.getElementById('ratingOverlay').addEventListener('click', function(e) {
        if (e.target === this) {
            closeRating();
        }
    });

    // Sentence mode overlay click handler
    document.getElementById('sentenceModeOverlay').addEventListener('click', function(e) {
        if (e.target === this) {
            closeSentenceMode();
        }
    });

    // Prevent default touch behavior
    document.getElementById('readPage').addEventListener('touchmove', function(e) {
        if (touchStartX !== null) {
            e.preventDefault();
        }
    }, { passive: false });

    document.getElementById('sentenceModeOverlay').addEventListener('touchmove', function(e) {
        if (touchStartX !== null) {
            e.preventDefault();
        }
    }, { passive: false });
}

// Audio Functions
function playPauseAudio() {
    if (!audioElement) {
        showStatus('No audio available for this text');
        return;
    }

    if (isPlaying) {
        audioElement.pause();
        clearInterval(currentAudioInterval);
    } else {
        audioElement.play();
        updateAudioProgress();
        currentAudioInterval = setInterval(updateAudioProgress, 100);
    }
    
    isPlaying = !isPlaying;
    updatePlayPauseButton();
}

function updatePlayPauseButton() {
    const buttons = document.querySelectorAll('button[onclick="playPauseAudio()"]');
    buttons.forEach(button => {
        button.textContent = isPlaying ? 'Pause' : 'Play';
    });
}

function updateAudioProgress() {
    if (!audioElement) return;
    
    const progressFills = document.querySelectorAll('.audio-progress-fill');
    const currentTimeSpans = document.querySelectorAll('#currentTime');
    const durationSpan = document.getElementById('duration');
    
    const progress = (audioElement.currentTime / audioElement.duration) * 100;
    
    progressFills.forEach(fill => {
        fill.style.width = `${progress}%`;
    });
    
    currentTimeSpans.forEach(span => {
        span.textContent = formatTime(audioElement.currentTime);
    });
    
    if (durationSpan) {
        durationSpan.textContent = formatTime(audioElement.duration);
    }
}

function seekAudio(offset) {
    if (!audioElement) return;
    audioElement.currentTime = Math.max(0, Math.min(audioElement.currentTime + offset, audioElement.duration));
    updateAudioProgress();
}

function playSentenceAudio() {
    if (!audioElement) {
        showStatus('No audio available for this text');
        return;
    }

    if (!timestamps || Object.keys(timestamps).length === 0) {
        console.error('No timestamps available:', timestamps);
        showStatus('No timestamps available for sentences');
        return;
    }

    if (timestamps[currentSentenceIndex] === undefined) {
        console.error('No timestamp for current sentence:', currentSentenceIndex);
        showStatus(`No timestamp for sentence ${currentSentenceIndex + 1}`);
        return;
    }

    const timestamp = timestamps[currentSentenceIndex];
    
    if (timestamp.start === undefined || timestamp.end === undefined) {
        console.error('Invalid timestamp data:', timestamp);
        showStatus('Invalid timestamp data for this sentence');
        return;
    }

    audioElement.currentTime = timestamp.start;
    
    // Remove any previous ended event listener
    audioElement.removeEventListener('timeupdate', checkSentenceEnd);
    
    // Add timeupdate listener to check for sentence end
    audioElement.addEventListener('timeupdate', checkSentenceEnd);
    
    audioElement.play();
    isPlaying = true;
    updatePlayPauseButton();
    updateAudioProgress();
}

function checkSentenceEnd() {
    if (!timestamps[currentSentenceIndex]) return;
    
    const timestamp = timestamps[currentSentenceIndex];
    if (audioElement.currentTime >= timestamp.end) {
        audioElement.pause();
        isPlaying = false;
        updatePlayPauseButton();
        audioElement.removeEventListener('timeupdate', checkSentenceEnd);
    }
}

function initializeAudio() {
    if (audioElement) {
        audioElement.addEventListener('ended', () => {
            isPlaying = false;
            updatePlayPauseButton();
            clearInterval(currentAudioInterval);
        });

        document.querySelectorAll('.audio-progress').forEach(progress => {
            progress.addEventListener('click', (e) => {
                const rect = e.currentTarget.getBoundingClientRect();
                const clickPosition = (e.clientX - rect.left) / rect.width;
                audioElement.currentTime = clickPosition * audioElement.duration;
                updateAudioProgress();
            });
        });
    }
}

// Navigation Functions
function setupSwipeListeners() {
    const readPage = document.getElementById('readPage');
    readPage.addEventListener('touchstart', handleTouchStartSwipe);
    readPage.addEventListener('touchmove', handleTouchMoveSwipe);
    readPage.addEventListener('touchend', (e) => handleTouchEndSwipe(e, true));

    const sentenceModeOverlay = document.getElementById('sentenceModeOverlay');
    sentenceModeOverlay.addEventListener('touchstart', handleTouchStartSwipe);
    sentenceModeOverlay.addEventListener('touchmove', handleTouchMoveSwipe);
    sentenceModeOverlay.addEventListener('touchend', (e) => handleTouchEndSwipe(e, false));
}

function handleTouchStartSwipe(e) {
    touchStartX = e.touches[0].clientX;
}

function handleTouchMoveSwipe(e) {
    if (!touchStartX) return;
    touchEndX = e.touches[0].clientX;
}

function handleTouchEndSwipe(e, isReadMode = true) {
    if (!touchStartX || !touchEndX) {
        touchStartX = null;
        touchEndX = null;
        return;
    }

    const swipeDistance = touchEndX - touchStartX;
    
    if (Math.abs(swipeDistance) >= SWIPE_THRESHOLD) {
        if (isReadMode) {
            if (swipeDistance > 0) {
                changePage(-1);
            } else {
                changePage(1);
            }
        } else {
            if (swipeDistance > 0) {
                navigateSentence(-1);
            } else {
                navigateSentence(1);
            }
        }
    }

    touchStartX = null;
    touchEndX = null;
}

// Status Message Functions
function showStatus(message, duration = 3000) {
    const status = document.getElementById('statusMessage');
    status.textContent = message;
    status.style.display = 'block';
    setTimeout(() => {
        status.style.display = 'none';
    }, duration);
}

// Page Management
function showPage(pageId) {
    document.querySelectorAll('.page, .overlay-page').forEach(page => {
        page.classList.remove('active');
    });

    if (pageId === 'home') {
        document.getElementById('homePage').classList.add('active');
    } else {
        document.getElementById(pageId + 'Page').classList.add('active');
    }
}

// Text Processing Functions
function processText(text, title = '') {
    sentences = text.match(/[^.!?]+[.!?]+/g) || [];
    sentences = sentences.map(s => s.trim());
    
    pages = paginateText(sentences);
    currentPage = 0;
    
    const titleElement = document.getElementById('textDisplayTitle');
    titleElement.textContent = title || 'Untitled Text';
    
    // Reset audio state
    audioElement = null;
    timestamps = {};
    
    // Find the text data by title
    const textData = Object.values(textLibrary).find(t => t.title === title);
    if (textData?.audio) {
        audioElement = new Audio(textData.audio);
        timestamps = textData.timestamps || {};
        
        // Debug log to check loaded timestamps
        console.log('Loaded timestamps:', timestamps);
        
        initializeAudio();
    }
    
    displayCurrentPage();
}

function paginateText(sentences) {
    const pages = [];
    let currentPageText = '';
    let currentPageSentences = [];
    
    sentences.forEach((sentence, sentenceIndex) => {
        if ((currentPageText + ' ' + sentence).length > CHARS_PER_PAGE) {
            if (currentPageText) {
                pages.push({
                    text: currentPageText.trim(),
                    sentences: currentPageSentences
                });
            }
            currentPageText = sentence;
            currentPageSentences = [sentenceIndex];
        } else {
            currentPageText += (currentPageText ? ' ' : '') + sentence;
            currentPageSentences.push(sentenceIndex);
        }
    });
    
    if (currentPageText) {
        pages.push({
            text: currentPageText.trim(),
            sentences: currentPageSentences
        });
    }
    
    return pages;
}

function displayCurrentPage() {
    const display = document.getElementById('textDisplay');
    const page = pages[currentPage];
    
    if (!page) return;
    
    const pageContent = page.sentences.map(sentenceIdx => {
        const sentence = sentences[sentenceIdx];
        const words = sentence.match(/\S+/g) || [];
        
        const processedWords = words.map(word => {
            const originalWord = word;
            const cleanWord = word.replace(/[^a-záéíóúüñÁÉÍÓÚÜÑA-Z\s]/g, '');
            const vocabEntry = vocabulary[cleanWord.toLowerCase()];
            
            let levelClass = 'word-new';
            if (vocabEntry) {
                levelClass = vocabEntry.level === 'untracked' ? 'word-untracked' : 
                           (vocabEntry.level === 0 ? 'word-new' : `word-level-${vocabEntry.level}`);
            }
            
            return `<span class="${levelClass}" 
                data-sentence-index="${sentenceIdx}"
                onclick="handleTextClick(this, '${encodeURIComponent(cleanWord)}')">${originalWord}</span>`;
        }).join(' ');
        
        return `<span class="sentence" data-sentence-index="${sentenceIdx}">${processedWords}</span>`;
    }).join(' ');
    
    display.innerHTML = `
        <div class="pagination-controls">
            <span>Page ${currentPage + 1} of ${pages.length}</span>
        </div>
        <div class="page-content">${pageContent}</div>
    `;

    const bottomNav = document.querySelector('.bottom-nav');
    bottomNav.innerHTML = `
        <button class="nav-button" onclick="changePage(-1)">Previous</button>
        <button class="nav-button sentence-mode-toggle" onclick="toggleSentenceMode()">Sentence Mode</button>
        ${currentPage === pages.length - 1 ? 
            '<button class="nav-button" style="min-width: 70px; background: #bbf7d0; color: #166534; font-weight: 500;" onclick="showCompletionModal()">I\'m Done Reading</button>' : 
            '<button class="nav-button" onclick="changePage(1)">Next</button>'
        }
    `;
}

function changePage(delta) {
    const newPage = currentPage + delta;
    if (newPage >= 0 && newPage < pages.length) {
        currentPage = newPage;
        displayCurrentPage();
    }
}

// Translation Functions
async function translateWord(word) {
    try {
        const response = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(word)}&langpair=es|en`);
        const data = await response.json();
        return data.responseData.translatedText;
    } catch (error) {
        console.error('Translation error:', error);
        return 'Translation failed';
    }
}

async function translateSentence(sentence) {
    try {
        const response = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(sentence)}&langpair=es|en`);
        const data = await response.json();
        return data.responseData.translatedText;
    } catch (error) {
        console.error('Translation error:', error);
        return 'Translation failed';
    }
}

// Vocabulary Management
function loadVocabulary() {
    const savedVocab = localStorage.getItem('vocabulary');
    if (savedVocab) {
        vocabulary = JSON.parse(savedVocab);
        updateKnownWordsCount();
    }
}

function saveVocabulary() {
    try {
        localStorage.setItem('vocabulary', JSON.stringify(vocabulary));
        
        const blob = new Blob([JSON.stringify(vocabulary, null, 2)], 
            { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'vocabulary.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        showStatus('Progress saved!');
    } catch (err) {
        showStatus('Error saving progress');
        console.error('Error:', err);
    }
}

function updateKnownWordsCount() {
    const knownWords = Object.values(vocabulary)
        .filter(word => word.level >= 4).length;
    document.getElementById('knownWordsCount').textContent = knownWords;
}

function saveTextLibrary() {
    localStorage.setItem('textLibrary', JSON.stringify(textLibrary));
}

function loadTextLibrary() {
    const savedLibrary = localStorage.getItem('textLibrary');
    if (savedLibrary) {
        textLibrary = JSON.parse(savedLibrary);
    }
}

// File Handling Functions
async function handleTextFileUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    try {
        const text = await file.text();
        const title = file.name.replace('.txt', '');
        
        const textId = Date.now().toString();
        const textData = {
            id: textId,
            title: title,
            content: text,
            dateCreated: new Date().toISOString()
        };
        
        textLibrary[textId] = textData;
        saveTextLibrary();

        processText(text, title);
        showPage('read');
        showStatus('Text loaded successfully!');
        
        event.target.value = '';
    } catch (error) {
        console.error('Error reading text file:', error);
        showStatus('Error loading text file');
    }
}

async function handleVocabFileUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    try {
        const content = await file.text();
        const newVocabulary = JSON.parse(content);
        
        vocabulary = { ...vocabulary, ...newVocabulary };
        localStorage.setItem('vocabulary', JSON.stringify(vocabulary));
        
        updateKnownWordsCount();
        showStatus('Vocabulary loaded successfully!');
        
        event.target.value = '';
    } catch (error) {
        console.error('Error reading vocabulary file:', error);
        showStatus('Error loading vocabulary file');
    }
}

function handleOverlayWordClick(element, encodedWord) {
    if (!encodedWord) return;
    
    const word = decodeURIComponent(encodedWord);
    
    if (isMultiSelectMode) {
        handleWordSelection(element, word);
        return;
    }
    
    currentWord = word;
    currentElement = element;
    
    const overlay = document.getElementById('ratingOverlay');
    const wordEntry = vocabulary[word.toLowerCase()];
    
    // Clear previous selection
    overlay.querySelectorAll('.rating-button').forEach(btn => {
        btn.classList.remove('selected');
    });
    
    // If word exists in vocabulary, highlight its current level
    if (wordEntry && wordEntry.level !== 'untracked' && wordEntry.level !== undefined) {
        const currentLevelButton = overlay.querySelector(`.rating-button.level-${wordEntry.level}`);
        if (currentLevelButton) {
            currentLevelButton.classList.add('selected');
        }
    }
    
    overlay.querySelector('.selected-word').textContent = word;
    overlay.style.display = 'block';
    
    if (wordEntry && wordEntry.definition) {
        overlay.querySelector('.word-translation').textContent = wordEntry.definition;
        overlay.querySelector('.custom-definition').value = wordEntry.definition;
    } else {
        overlay.querySelector('.word-translation').textContent = 'Loading...';
        overlay.querySelector('.custom-definition').value = '';
        
        translateWord(word).then(translation => {
            if (currentWord === word) {
                overlay.querySelector('.word-translation').textContent = translation;
            }
        }).catch(error => {
            console.error('Translation error:', error);
            overlay.querySelector('.word-translation').textContent = 'Translation failed';
        });
    }
}

// Text Handling Functions
function handleTextClick(element, encodedWord) {
    if (touchStartX !== null) return;
    
    const word = decodeURIComponent(encodedWord);
    const sentenceIndex = parseInt(element.closest('.sentence').dataset.sentenceIndex);
    
    if (isMultiSelectMode) {
        handleWordSelection(element, word);
        return;
    }

    if (sentenceMode && !isMultiSelectMode) {
        showSentenceOverlay(sentenceIndex);
        return;
    }

    handleWordClick(element, encodedWord);
}

async function handleWordClick(element, encodedWord) {
    if (!encodedWord) return;
    
    const word = decodeURIComponent(encodedWord);
    
    if (isMultiSelectMode) {
        handleWordSelection(element, word);
        return;
    }
    
    currentWord = word;
    currentElement = element;
    
    const overlay = document.getElementById('ratingOverlay');
    const wordEntry = vocabulary[word.toLowerCase()];
    
    overlay.querySelectorAll('.rating-button').forEach(btn => {
        btn.classList.remove('selected');
    });
    
    if (wordEntry && wordEntry.level !== 'untracked' && wordEntry.level !== undefined) {
        const currentLevelButton = overlay.querySelector(`.rating-button.level-${wordEntry.level}`);
        if (currentLevelButton) {
            currentLevelButton.classList.add('selected');
        }
    }
    
    overlay.querySelector('.selected-word').textContent = word;
    overlay.style.display = 'block';
    
    if (wordEntry && wordEntry.definition) {
        overlay.querySelector('.word-translation').textContent = wordEntry.definition;
        overlay.querySelector('.custom-definition').value = wordEntry.definition;
    } else {
        overlay.querySelector('.word-translation').textContent = 'Loading...';
        overlay.querySelector('.custom-definition').value = '';
        
        translateWord(word).then(translation => {
            if (currentWord === word) {
                overlay.querySelector('.word-translation').textContent = translation;
            }
        }).catch(error => {
            console.error('Translation error:', error);
            overlay.querySelector('.word-translation').textContent = 'Translation failed';
        });
    }
}

// Word Rating Functions
function updateWordRating(word, element, level) {
    element?.classList.remove('word-new', 'word-level-1', 'word-level-2', 
        'word-level-3', 'word-level-4', 'word-level-5', 'word-untracked');
    
    if (element) {
        if (level === 'untracked') {
            element.classList.add('word-untracked');
        } else {
            element.classList.add(level === 0 ? 'word-new' : `word-level-${level}`);
        }
    }
    
    const wordKey = word.toLowerCase();
    
    if (level === 'untracked') {
        delete vocabulary[wordKey];
    } else {
        const customDefinition = document.querySelector('.custom-definition').value;
        const suggestedDefinition = document.querySelector('.word-translation').textContent;
        
        vocabulary[wordKey] = {
            word: word,
            level: level,
            timestamp: new Date().toISOString(),
            definition: customDefinition || suggestedDefinition,
            isPhrase: word.includes(' ')
        };

        if (word.includes(' ')) {
            const words = word.split(' ');
            words.forEach(singleWord => {
                const singleWordKey = singleWord.toLowerCase();
                if (!vocabulary[singleWordKey]) {
                    vocabulary[singleWordKey] = {
                        word: singleWord,
                        level: level,
                        timestamp: new Date().toISOString(),
                        definition: '',
                        partOfPhrase: wordKey
                    };
                }
            });
        }
    }

    document.querySelectorAll('#textDisplay span, .sentence-content span').forEach(span => {
        const spanText = span.textContent.replace(/[^a-záéíóúüñÁÉÍÓÚÜÑA-Z\s]/g, '');
        const spanLower = spanText.toLowerCase();
        
        if (word.includes(' ')) {
            const words = word.toLowerCase().split(' ');
            if (words.includes(spanLower)) {
                if (level === 'untracked') {
                    span.className = 'word-untracked';
                } else {
                    span.className = level === 0 ? 'word-new' : `word-level-${level}`;
                }
            }
        } else if (spanLower === wordKey) {
            if (level === 'untracked') {
                span.className = 'word-untracked';
            } else {
                span.className = level === 0 ? 'word-new' : `word-level-${level}`;
            }
        }
    });

    updateKnownWordsCount();
    localStorage.setItem('vocabulary', JSON.stringify(vocabulary));
}

function closeRating() {
    const overlay = document.getElementById('ratingOverlay');
    overlay.style.display = 'none';
    
    overlay.querySelectorAll('.rating-button').forEach(btn => {
        btn.classList.remove('selected');
    });
    
    currentWord = null;
    currentElement = null;
}

function rateWord(level) {
    if (currentElement && currentWord) {
        updateWordRating(currentWord, currentElement, level);
    }
    closeRating();
}

function markAsUntracked() {
    if (currentElement && currentWord) {
        const wordKey = currentWord.toLowerCase();
        
        vocabulary[wordKey] = {
            word: currentWord,
            level: 'untracked',
            timestamp: new Date().toISOString()
        };

        document.querySelectorAll('#textDisplay span, .sentence-content span, .sentence span').forEach(span => {
            const spanWord = span.textContent.replace(/[^a-záéíóúüñÁÉÍÓÚÜÑA-Z\s]/g, '');
            if (spanWord.toLowerCase() === wordKey) {
                span.className = 'word-untracked';
            }
        });

        updateKnownWordsCount();
        localStorage.setItem('vocabulary', JSON.stringify(vocabulary));
    }
    closeRating();
}

// Multi-word Selection Functions
function handleMouseDown(e) {
    const element = e.target.closest('span[onclick]');
    if (!element || isMultiSelectMode) return;
    
    initialX = e.clientX;
    initialY = e.clientY;
    
    longPressTimeout = setTimeout(() => {
        handleLongPress(e);
    }, 500);
}

function handleMouseMove(e) {
    if (Math.abs(e.clientX - initialX) > 5 || Math.abs(e.clientY - initialY) > 5) {
        clearTimeout(longPressTimeout);
    }
}

function handleTouchStart(e) {
    const element = e.target.closest('span[onclick]');
    if (!element || isMultiSelectMode) return;
    
    const touch = e.touches[0];
    initialX = touch.clientX;
    initialY = touch.clientY;
    
    longPressTimeout = setTimeout(() => {
        handleLongPress(e);
    }, 500);
}

function handleTouchMove(e) {
    const touch = e.touches[0];
    if (Math.abs(touch.clientX - initialX) > 5 || Math.abs(touch.clientY - initialY) > 5) {
        clearTimeout(longPressTimeout);
    }
}

function handleLongPress(e) {
    const element = e.target.closest('span[onclick]');
    if (!element) return;
    
    const rect = element.getBoundingClientRect();
    startMultiSelect(rect.left, rect.top - 40);
}

function startMultiSelect(x, y) {
    isMultiSelectMode = true;
    selectedWords.clear();
    
    const doneButton = document.getElementById('floatingDone');
    doneButton.style.display = 'block';
    doneButton.style.left = `${x}px`;
    doneButton.style.top = `${y}px`;
    
    updateSelectedCount();
}

function endMultiSelect() {
    isMultiSelectMode = false;
    selectedWords.clear();
    
    document.getElementById('floatingDone').style.display = 'none';
    
    document.querySelectorAll('.word-selected').forEach(el => {
        el.classList.remove('word-selected');
    });
}

function handleDoneButtonClick() {
    if (selectedWords.size > 0) {
        const combinedWord = Array.from(selectedWords).join(' ');
        currentWord = combinedWord;
        currentElement = document.querySelector('.word-selected');
        
        const overlay = document.getElementById('ratingOverlay');
        overlay.querySelector('.selected-word').textContent = combinedWord;
        overlay.style.display = 'block';
        
        translateWord(combinedWord).then(translation => {
            if (currentWord === combinedWord) {
                overlay.querySelector('.word-translation').textContent = translation;
            }
        }).catch(error => {
            console.error('Translation error:', error);
            overlay.querySelector('.word-translation').textContent = 'Translation failed';
        });
    }
    endMultiSelect();
}

function updateSelectedCount() {
    document.getElementById('selectedCount').textContent = selectedWords.size;
}

function handleWordSelection(element, word) {
    if (selectedWords.has(word)) {
        selectedWords.delete(word);
        element.classList.remove('word-selected');
    } else {
        selectedWords.add(word);
        element.classList.add('word-selected');
    }
    updateSelectedCount();
}

// Sentence Mode Functions
function toggleSentenceMode() {
    sentenceMode = !sentenceMode;
    
    if (sentenceMode) {
        showSentenceOverlay(lastClickedSentenceIndex || 0);
    } else {
        closeSentenceMode();
    }
}

async function showSentenceOverlay(index) {
    currentSentenceIndex = index;
    const overlay = document.getElementById('sentenceModeOverlay');
    const sentence = sentences[index];
    
    const words = sentence.match(/\S+/g) || [];
    const content = overlay.querySelector('.sentence-content');
    content.innerHTML = words.map(word => {
        const originalWord = word;
        const cleanWord = word.replace(/[^a-záéíóúüñÁÉÍÓÚÜÑA-Z\s]/g, '');
        const vocabEntry = vocabulary[cleanWord.toLowerCase()];
        
        let levelClass = 'word-new';
        if (vocabEntry) {
            levelClass = vocabEntry.level === 'untracked' ? 'word-untracked' : 
                       (vocabEntry.level === 0 ? 'word-new' : `word-level-${vocabEntry.level}`);
        }

        // Add word-selected class if word is in selectedWords set
        if (isMultiSelectMode && selectedWords.has(cleanWord)) {
            levelClass += ' word-selected';
        }
        
        return `<span class="${levelClass}" 
            onclick="handleOverlayWordClick(this, '${encodeURIComponent(cleanWord)}')">${originalWord}</span>`;
    }).join(' ');
    
    overlay.style.display = 'block';
    updateSentenceNavigation();
    
    const translationDiv = overlay.querySelector('.sentence-translation');
    translationDiv.textContent = 'Translating...';
    document.querySelector('.translation-section').classList.add('hidden');
    translationVisible = false;
    
    translateSentence(sentence).then(translation => {
        if (currentSentenceIndex === index) {
            translationDiv.textContent = translation;
        }
    }).catch(error => {
        console.error('Translation error:', error);
        if (currentSentenceIndex === index) {
            translationDiv.textContent = 'Translation failed';
        }
    });
}

function toggleTranslation() {
    translationVisible = !translationVisible;
    const translationSection = document.querySelector('.translation-section');
    translationSection.classList.toggle('hidden');
}

function updateSentenceNavigation() {
    const counter = document.getElementById('sentenceCounter');
    counter.textContent = `${currentSentenceIndex + 1} / ${sentences.length}`;
}

function navigateSentence(direction) {
    const newIndex = currentSentenceIndex + direction;
    if (newIndex >= 0 && newIndex < sentences.length) {
        currentSentenceIndex = newIndex;
        showSentenceOverlay(currentSentenceIndex);
    }
}

function closeSentenceMode() {
    document.getElementById('sentenceModeOverlay').style.display = 'none';
    document.querySelectorAll('.sentence-highlight').forEach(el => {
        el.classList.remove('sentence-highlight');
    });
    sentenceMode = false;
}

// Text Library Functions
function showTextLibrary() {
    showPage('textLibrary');
    updateTextLibraryTable();
}

function updateTextLibraryTable() {
    const tbody = document.querySelector('#textLibraryTable tbody');
    const searchTerm = document.getElementById('textSearch')?.value?.toLowerCase() || '';
    
    tbody.innerHTML = '';
    
    Object.entries(textLibrary)
        .filter(([id, text]) =>text.title.toLowerCase().includes(searchTerm))
        .sort((a, b) => new Date(b[1].dateCreated) - new Date(a[1].dateCreated))
        .forEach(([id, text]) => {
            const row = document.createElement('tr');
            const date = new Date(text.dateCreated).toLocaleDateString();
            row.innerHTML = `
                <td>${text.title}</td>
                <td>${date}</td>
                <td>
                    <button class="action-button" onclick="openText('${id}')">Open</button>
                    <button class="action-button" onclick="deleteText('${id}')">Delete</button>
                </td>
            `;
            tbody.appendChild(row);
        });
}

function openText(textId) {
    const text = textLibrary[textId];
    if (text) {
        processText(text.content, text.title);
        showPage('read');
    }
}

function deleteText(textId) {
    if (confirm('Are you sure you want to delete this text?')) {
        delete textLibrary[textId];
        saveTextLibrary();
        updateTextLibraryTable();
    }
}

// Vocabulary Overview Functions
function showVocabularyOverview() {
    showPage('vocabularyOverview');
    updateVocabularyTable();
}

function updateVocabularyTable() {
    const tbody = document.querySelector('#vocabularyTable tbody');
    const searchTerm = document.getElementById('vocabularySearch').value.toLowerCase();
    const levelFilter = document.getElementById('levelFilter').value;
    
    tbody.innerHTML = '';
    
    Object.entries(vocabulary)
        .filter(([key, entry]) => {
            const matchesSearch = entry.word.toLowerCase().includes(searchTerm) ||
                (entry.definition || '').toLowerCase().includes(searchTerm);
            const matchesLevel = levelFilter === 'all' || entry.level.toString() === levelFilter;
            return matchesSearch && matchesLevel;
        })
        .sort((a, b) => a[1].word.localeCompare(b[1].word))
        .forEach(([key, entry]) => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${entry.word}</td>
                <td>${entry.definition || 'No definition'}</td>
                <td>${entry.level}</td>
                <td>
                    <button class="edit-definition" onclick="editDefinition('${entry.word}')">
                        Edit
                    </button>
                </td>
            `;
            tbody.appendChild(row);
        });
}

function editDefinition(word) {
    currentWord = word;
    const entry = vocabulary[word.toLowerCase()];
    
    const overlay = document.getElementById('ratingOverlay');
    overlay.querySelector('.selected-word').textContent = word;
    overlay.querySelector('.word-translation').textContent = entry.definition || 'No definition';
    overlay.querySelector('.custom-definition').value = entry.definition || '';
    
    overlay.style.display = 'block';
}

// Save and Load Functions
function saveTextAsFile(text, filename) {
    const blob = new Blob([text], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${filename}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function saveAndRead() {
    const title = document.getElementById('textTitle').value.trim();
    const content = document.getElementById('textInput').value.trim();
    
    if (!title) {
        showStatus('Please enter a title for your text');
        return;
    }
    
    if (!content) {
        showStatus('Please enter some text content');
        return;
    }
    
    const textId = Date.now().toString();
    
    const textData = {
        id: textId,
        title: title,
        content: content,
        dateCreated: new Date().toISOString()
    };
    
    textLibrary[textId] = textData;
    saveTextLibrary();
    
    saveTextAsFile(content, title);
    
    localStorage.removeItem('draftText');
    
    processText(content, title);
    
    showPage('read');
    
    showStatus('Text saved successfully!');
    
    document.getElementById('textTitle').value = '';
    document.getElementById('textInput').value = '';
}

// Audio Selection and Management Functions
function showTextSelection() {
    const modal = document.getElementById('textSelectionModal');
    updateTextSelectionList();
    modal.style.display = 'block';
}

function closeTextSelection() {
    document.getElementById('textSelectionModal').style.display = 'none';
}

function updateTextSelectionList() {
    const container = document.getElementById('textSelectionList');
    const searchTerm = document.getElementById('textSearchAudio').value.toLowerCase();
    
    container.innerHTML = '';
    
    Object.entries(textLibrary)
        .filter(([id, text]) => text.title.toLowerCase().includes(searchTerm))
        .sort((a, b) => new Date(b[1].dateCreated) - new Date(a[1].dateCreated))
        .forEach(([id, text]) => {
            const div = document.createElement('div');
            div.className = `text-selection-item ${text.audio ? 'has-audio' : ''}`;
            div.innerHTML = `
                <div class="text-info">
                    <div class="text-title">${text.title}</div>
                    <div class="text-date">${new Date(text.dateCreated).toLocaleDateString()}</div>
                </div>
                <div class="audio-status">
                    ${text.audio ? 'Has audio' : 'No audio'}
                </div>
            `;
            div.onclick = () => selectTextForAudio(id);
            container.appendChild(div);
        });
}

function selectTextForAudio(textId) {
    selectedTextId = textId;
    document.getElementById('loadAudioInput').click();
}

function handleAudioUpload(event) {
    const file = event.target.files[0];
    if (!file || !selectedTextId) return;

    const reader = new FileReader();
    reader.onload = function(e) {
        currentAudioFile = e.target.result;
        audioElement = new Audio(currentAudioFile);
        audioElement.addEventListener('loadedmetadata', () => {
            closeTextSelection();
            showTimestampEditor();
        });
    };
    reader.readAsDataURL(file);
    
    event.target.value = '';
}

function showTimestampEditor() {
    const editor = document.getElementById('timestampEditor');
    const rowsContainer = document.getElementById('timestampRows');
    
    rowsContainer.innerHTML = '';
    sentences.forEach((sentence, index) => {
        const row = document.createElement('div');
        row.className = 'timestamp-row';
        row.innerHTML = `
            <div class="timestamp-text">${sentence}</div>
            <input type="text" 
                   class="timestamp-input" 
                   id="timestamp-${index}"
                   placeholder="0:00"
                   value="${formatTime(timestamps[index]?.start || 0)}">
            <button onclick="markCurrentTime(${index})">Mark</button>
        `;
        rowsContainer.appendChild(row);
    });
    
    editor.style.display = 'block';
}

function markCurrentTime(index) {
    if (!audioElement) return;
    
    const input = document.getElementById(`timestamp-${index}`);
    const currentTime = audioElement.currentTime;
    input.value = formatTime(currentTime);
    
    // Update the current timestamp
    timestamps[index] = {
        start: currentTime,
        end: null  // Will be set when next timestamp is marked
    };
    
    // Update the previous timestamp's end time
    if (index > 0 && timestamps[index - 1]) {
        timestamps[index - 1].end = currentTime;
    }
    
    // If this is the last sentence, set end time to audio duration
    if (index === sentences.length - 1) {
        timestamps[index].end = audioElement.duration;
    }
}

function formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}

function saveTimestamps() {
    if (!selectedTextId || !textLibrary[selectedTextId]) {
        showStatus('Error: No text selected');
        return;
    }

    // Validate and clean timestamps
    const validatedTimestamps = {};
    let previousEnd = 0;

    sentences.forEach((sentence, index) => {
        const timestampInput = document.getElementById(`timestamp-${index}`);
        if (!timestampInput) return;

        const timeValue = parseTimeString(timestampInput.value);
        if (timeValue !== null) {
            validatedTimestamps[index] = {
                start: timeValue,
                end: null // Will be set in the next iteration
            };

            // Set the end time of the previous timestamp
            if (index > 0 && validatedTimestamps[index - 1]) {
                validatedTimestamps[index - 1].end = timeValue;
            }

            previousEnd = timeValue;
        }
    });

    // Set the end time for the last sentence
    const lastIndex = Object.keys(validatedTimestamps).length - 1;
    if (lastIndex >= 0 && audioElement) {
        validatedTimestamps[lastIndex].end = audioElement.duration;
    }

    // Save to text library
    textLibrary[selectedTextId].audio = currentAudioFile;
    textLibrary[selectedTextId].timestamps = validatedTimestamps;
    saveTextLibrary();

    // Update current timestamps
    timestamps = validatedTimestamps;

    closeTimestampEditor();
    showStatus('Audio synchronized successfully!');
}

function parseTimeString(timeStr) {
    if (!timeStr) return null;
    
    const parts = timeStr.split(':');
    if (parts.length !== 2) return null;
    
    const minutes = parseInt(parts[0]);
    const seconds = parseInt(parts[1]);
    
    if (isNaN(minutes) || isNaN(seconds)) return null;
    
    return minutes * 60 + seconds;
}

function closeTimestampEditor() {
    document.getElementById('timestampEditor').style.display = 'none';
}

function checkTimestamps() {
    console.log('Current timestamps:', timestamps);
    console.log('Current sentence index:', currentSentenceIndex);
    if (timestamps[currentSentenceIndex]) {
        console.log('Current sentence timing:', 
            formatTime(timestamps[currentSentenceIndex].start), 
            'to', 
            formatTime(timestamps[currentSentenceIndex].end));
    }
}

// Keyboard Shortcuts Setup
function setupKeyboardShortcuts() {
    document.addEventListener('keydown', function(e) {
        if (document.getElementById('ratingOverlay').style.display === 'block') {
            if (e.key >= '1' && e.key <= '5') {
                rateWord(parseInt(e.key));
            } else if (e.key === 'n') {
                markAsNew();
            } else if (e.key === 'Escape') {
                closeRating();
            }
        } else if (document.getElementById('sentenceModeOverlay').style.display === 'block') {
            if (e.key === 'ArrowLeft') {
                navigateSentence(-1);
            } else if (e.key === 'ArrowRight') {
                navigateSentence(1);
            } else if (e.key === 'Escape') {
                closeSentenceMode();
            } else if (e.key === 't') {
                toggleTranslation();
            }
        }
    });
}

// Auto-save draft
setInterval(() => {
    const text = document.getElementById('textInput').value;
    const title = document.getElementById('textTitle').value;
    if (text.trim() || title.trim()) {
        localStorage.setItem('draftText', JSON.stringify({
            title: title,
            content: text
        }));
    }
}, 30000);

function notifyCompletion() {
    window.parent.postMessage({
        type: 'exerciseComplete',
        exercise: 'reading',
        day: currentDay
    }, '*');
}
function showCompletionModal() {
    const modal = document.createElement('div');
    modal.style.position = 'fixed';
    modal.style.top = '0';
    modal.style.left = '0';
    modal.style.width = '100%';
    modal.style.height = '100%';
    modal.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
    modal.style.display = 'flex';
    modal.style.justifyContent = 'center';
    modal.style.alignItems = 'center';
    modal.style.zIndex = '3000';

    const modalContent = document.createElement('div');
    modalContent.style.background = 'white';
    modalContent.style.padding = '30px';
    modalContent.style.borderRadius = '8px';
    modalContent.style.textAlign = 'center';
    modalContent.innerHTML = `
        <h2>Reading Complete!</h2>
        <p>Great job finishing the text! 🎉</p>
       <button class="button exercise-button" onclick="notifyCompletion()" style="margin-top: 20px; padding: 12px 24px; background: #2c3e50; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 1rem; font-weight: 500;">Complete & Continue</button>
    `;

    modal.appendChild(modalContent);
    document.body.appendChild(modal);
}
</script>
</body>
</html>